### python正则

python 中在字符串前加`r`表示完全不进行字符串转义，例如 r'\n' 就是两个字符：`\` 和 `n` 而不是换行符

最简单的用法是

```python
pattern = re.compile(r'...')
pattern.findall(str)
```

该方法返回一个列表，元素是在 `str` 中被匹配到的字符串



### 匹配字符

字符分为两类，一类是普通字符（写出就直接匹配），另一类是特殊字符（按照某种规则匹配），也叫元字符

元字符总共有这些

```
. * + ? [] {} $ | () \ ^
```



#### 基本匹配

| 字符       | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| **.**      | 匹配**除了换行符**之外的**单个**字符                         |
| *****      | 匹配**前面的**子表达式任意次（包括 0 次）                    |
| **+**      | 匹配**前面的**子表达式至少 1 次                              |
| **？**     | 匹配**前面的**子表达式至多 1 次（即 0 次和 1 次）            |
| **{m}**    | 指定**前一个字符**出现 m 次                                  |
| **{m,}**   | 指定**前一个字符**至少出现 m 次，至多可无限次                |
| **{m, n}** | 匹配**前一个字符** [m, n] 次，两边都是闭区间                 |
| **\\**     | 对特殊字符进行转义，比如确实想匹配 "*****" 则写 "**\\***"    |
| **[ABC]**  | 表示匹配任意候选字符（此处指 A、B、C之一），注意不能用 `,` 来分隔开 |
| **[^ABC]** | [] 开头加上 `^` 表示匹配任意非候选字符                       |
| **^**      | 在 [] 之外表示匹配文本的起始位置                             |
| **$**      | 表示匹配文本的结束位置                                       |

注意在 `[]` 内 `.` `*` `+` `?`  都不再有特殊含义，就是字面意义



#### 单行与多行模式

在单行模式下，`^` 会将整个字符串视为一行，进而只匹配开头；

在多行模式下，`^` 会将每一行字符串视为一行，进而匹配每一行的开头

python 的 re 默认是单行模式，但可以在编译选项中开启多行模式

```python
re.compile(r'...', re.M)
```

`$` 同理，单行模式将整个字符串视为一行，多行模式下视为多行



#### 内置快捷匹配

| 字符 | 含义                                          |
| ---- | --------------------------------------------- |
| \d   | 相当于[0-9]                                   |
| \D   | 相当于[\^0-9]                                 |
| \s   | 任意空白字符，相当于[\t\n\r\f\v]              |
| \S   | 匹配非空白字符，相当于 `\s` 的反面            |
| \w   | 匹配文字字符，ascii 模式下相当于 [a-zA-Z0-9_] |
| \W   | 匹配非文字字符，`\w` 的反面，                 |

`[]` 内部还能嵌套 `[]`，例如 `[\d]`就相当于 `[0-9]`，由此可以组合 `[\dA-Z]` 相当于 `[0-9A-Z]`



#### 贪婪与非贪婪

`+`，`?`，`*` 都是贪婪匹配，也就是说能尽可能多地匹配就尽量匹配，比如

```python
str = r"<html><\html>"
pattern = re.compile(r'<.*>')
pattern.findall(str)	# -> ['<html><\html>']

str = r"<>>"
pattern = re.compile(r'<.?>')
pattern.findall(str)	# -> ['<>>']
```

如果想启用非贪婪模式，那么就可以在 `+`、`*`、`?` 之后加上 `?`，表示非贪婪模式，一旦匹配条件满足，无论后面是否仍有满足条件的字符串都立即返回

```python
str = r"<html><\html>"
pattern = re.compile(r'<.*?>')
pattern.findall(str)	# -> ['<html>', '<\html>']
```



### 分组和引用

在用正则表达式选择出特征之后，可以继续对选择出的字符串用 `()` 进行分组。原来匹配上的整个字符串被称为 `full match`，而在整个匹配中 `()` 内的内容称为 `group`，以阿拉伯数字排序：`group1`、`group2`、...。

`group0` 指 `full match`



python中当compile编译的模式只有一个组，返回的就会是字符串构成的列表；但当是有多个组时，返回的就是元组组成的列表，每个元组依序为 `group1`、`group2`

```python
pattern = re.compile(r'^(.+),.+(\d{9})', re.M)

str = r'''
张三,手机号123456789
李四,手机号123456789
王麻子,手机号123456789
'''

pattern.findall(str)

# -> [('张三', '123456789'), ('李四', '123456789'), ('王麻子', '123456789')]
```



### 预言

| 符号    | 含义                                                         |
| ------- | ------------------------------------------------------------ |
| `(?=)`  | 正向预查。比如`Code(?=Sheep)`能匹配`CodeSheep`中的`Code`，但不能匹配`CodePig`中的`Code`。 |
| `(?!)`  | 正向否定预查。比如`Code(?!Sheep)`不能匹配`CodeSheep`中的`Code`，但能匹配`CodePig`中的`Code`。 |
| `(?<=)` | 反向预查。比如`(?<=Code)Sheep`能匹配`CodeSheep`中的`Sheep`，但不能匹配`ReadSheep`中的`Sheep`。 |
| `(?<!)` | 反向否定预查。比如`(?<!Code)Sheep`不能匹配`CodeSheep`中的`Sheep`，但能匹配`ReadSheep`中的`Sheep`。 |

```python
pattern = re.compile(r'Code\d(?=Sheep)', re.M)

str = r'''
Code1Sheep
Code2Sheep
Code3Pig
'''

pattern.findall(str)

# -> ['Code1', 'Code2']
```



### 标记

#### ASCII

`\w` 默认就是匹配 Unicode 文字字符， 如果想指定 `\w`  只匹配 ASCII 码字符，可以在 compile 时指定

```python
pattern = re.compile(r'\w', re.ASCII)
```



#### MULTILINE

开启多行模式



#### IGNORECASE

忽略大小写



### 分割和替换

#### 分割

有的时候字符串比较凌乱，不一定可以用一种统一的方式切割，当我们想将其切割时可以用正则匹配出划分字符串。

例如

```python
str = r'z; d, f  q/ s'
pattern = re.split(r'[;,/ ]+', str)
# -> ['z', 'd', 'f', 'q', 's']
```



#### 替换

```python
mystr = r'av12138'

def subFunc(match):
    full = match.group(0)
    num = match.group(1)
    return str(int(num) + 114514)

re.sub(r'av(\d+)', subFunc, mystr)
```

`sub` 的第一个参数是正则模式，第二个参数是替换规则，第三个是待匹配字符串

尤其值得注意的是，替换规则的参数是 `match`，即一个`Macth`对象，而返回值是被选中字符最终被替换成的值