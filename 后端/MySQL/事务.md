### 事务概观

事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作
请求，即这些操作**要么同时成功**，**要么同时失败**。

MySQL 默认事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务。



### 事务操作

- 查看事务提交方式

  ```sql
  select @@autocommit
  -- 如果结果为 0 则说明关闭，为 1 则说明开启
  ```

- 设置事务手动/自动提交

  ```sql
  set @@autocommit = 0
  set @@autocommit = 1
  
  -- 或者
  start transaction
  ```

- 提交事务

  ```sql
  commit
  ```

- 回滚事务

  ```sql
  rollback
  ```



### 事务四大特性(ACID)

- 原子性(Atomicity)

  > 事务是不可分割的最小操作单元，要么全部成功，要么全部失败

- 一致性（Consistency）

  > 事务完成时，必须使所有的数据都保持一致状态

- 隔离性（Isolation)

  > 数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行

- 持久性（(Durability)

  > 事务一旦提交或回滚，它对数据库中的数据的改变就是永久的



### 并发事务

| 问题       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 脏读       | 一个事务读到另外一个事务尚未完成提交的数据。                 |
| 不可重复读 | 一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。<br>这是因为在两次读取之间数据被另一个事务修改 |
| 幻读       | 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，而去查询又显示不存在，好像出现了”幻影”。<br>这是因为在插入数据时该数据已经抢先被另一个事务插入 |
| 丢失更新   | 两个事务在并发下同时进行更新，后一个事务的更新覆盖了前一个事务更新的情况，此时哪怕回滚也无法回滚到自己的更新。在前一个事务看来数据就好像没有被更新一样 |





### 隔离级别

隔离级别有四种，分别是：读未提交、读已提交、可重复读、序列化。不同的数据库可能选择不同的隔离别别以对并发事务进行不同程度的解决

- 读未提交： Read Uncommitted

  > 顾名思义，就是一个事务可以读取另一个未提交事务的数据。这是隔离的最低级别，它存在4个常见问题（脏读、不可重复读、幻读、丢失更新）

- 读已提交： Read Committed

  > 顾名思义，就是一个事务要等另一个事务提交后才能读取数据。 它解决了脏读问题，存在3个常见问题（不可重复读、幻读、丢失更新）

- 可重复读： Repeatable Read

  > 就是在开始读取数据（事务开启）时，不再允许修改操作 。它解决了脏读和不可重复读，还存在2个常见问题（幻读、丢失更新）

- 序列化： Serializable

  > 序列化，或串行化。就是将每个事务按一定的顺序去执行，它将隔离问题全部解决，但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

以上隔离级别从上到下数据安全性越来越高，性能越来越差



大多数数据库默认的事务隔离级别是 Read Committed，比如 SQL Server , Oracle。但 MySQL 的默认隔离级别是 Repeatable Read。



#### 查看事务隔离级别

```sql
SELECT @@TRANSACTION_ISOLATION;
```



#### 设置事务隔离级别

```sql
SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE]
```

SESSION 表示仅针对当前会话有效，GLOBAL 表示全局有效


