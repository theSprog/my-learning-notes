### DFA与NFA

- NFA：状态对同一字符可能有多个转移，因为状态允许在空串 `ε`  上转移
- DFA：转移函数确定的FA，不允许 `ε` 转移



### 从 RE 到 NFA：Thompson 构造法

![image-20221009143351859](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221009143351859.png)

> 将原正则表达式的每一个字符分解为简单 NFA，然后按照优先级顺序：括号 > 闭包 > 连接 > 选择，对 NFA 集合不断进行上图中的连接、选择和闭包对应的转换，最终得到 RE 对应的 NFA。该 NFA 显然还有许多冗余



#### 优先级表示

要让机器理解程序优先级，我们可以构建表达式树。

如对于正则 `a(b|c)*`，对应的表达式树如下（括号已经表示在树的层级中）：

![image-20221009144304512](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221009144304512.png)

对该树进行后序遍历可得：`a -> b -> c -> (b|c) -> (b|c)* -> a(b|c)*`，先进行对 `a、b、c` 的构建，即简单 NFA 的构建，然后将其应用非叶子节点所定义的规则——叶子节点定义字符，非叶子节点定义规则——进行转换



### 从 NFA 到 DFA：子集构造法

#### 理论

它是将 NFA 映射出一个与 DFA 关系对应的表格，假设该表格为 T。

表格 T 的行表示有效配置（用 q 表示，q 是一个集合，是 NFA 的子集），列表示对应的 Σ 中的字符

> 有效配置：NFA 中输入某个字符串可以到达的状态，在算法停止时，每个 $q_i$ 对应 DFA 中一个状态
>
> Σ 表示该 NFA 的所有字符组成的字符集
>
> 
>
> - NFA 的每一个状态以 $n_i$ 表示，$n_0$ 表示初始状态。
> - δ(q,c) 是转移函数，表示 q 中状态经过一个 c 后所到的状态，换句话说将 NFA 的转移函数应用到 q 的每一个元素
>
> - ε-closure(N) 是一个函数，表示 N 中所有状态在经过若干个 ε 后可到达的状态的集合

```python
q0 = ε-closure({n0})
Q = {q0}
workList = {q0}

while( workList is not empty):
    remove q from workList
    for c in Σ:
        t =  ε-closure( δ(q,c) ) # δ(q,c) 表示 q 中状态经过一个 c 后所到的状态
        T[q][c] = t
        if t not in Q:
            add t to Q
            add t to workList
```

当算法结束时，Q包含了 NFA 的所有有效配置，而 T 则表示了他们之间的转移。

我们将每一个 $q_i$ 集合命名为状态 $d_i$，根据 T 可以得出 $d_i$ 之间的转换，当 $q_i$ 中包含任意一个原 NFA 的接收状态时，$d_i$ 也被标记为接收状态。$q_0$ 即 $d_0$，即 DFA 的起始状态



#### 举例

- $q_0$ 即 $\{n_0\}$ ，在接收到 $a$ 后可以到达 $q_1$ 即 $\{n_1, n_2, n_3, n_4, n_6, n_9\}$，接收到 $b$ 和 $c$ 则无效
- 对于新加入的 $q_1$ ，同样对其进行 $\sum$ 字符枚举，得到两个新状态：$q_2$ 和 $q_3$
- 而对于 $q_2$ 和 $q_3$ 则不会产生新状态，只会在已有状态之间转移，最终 workList 归零，算法结束
- 根据 T 表得出 DFA，任何存在状态 $n_9$ 的 $q_i$ 集合都被标记为接受状态

<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221009153930635.png" alt="image-20221009153930635" style="zoom:80%;" />



### 从 DFA 到最小 DFA：Hopcroft 算法

DFA最小化不会减少扫描字符串的时间，但却会减少 DFA 在内存中占用的空间，有利于 CPU 的高速缓存



#### 理论

假设 DFA 根据行为等价性划分为 $P = \{p_1,p_2,...,p_m\}$。

> 所谓行为等价，就是指对应于一个集合 S，里面的所有元素在面对同一个任意字符 c 时会表现出同样的行为，那么该集合就被称为等价类集合
>
> 形式化地讲：如果已知 $d_i, d_j \in p_s$ 且 $\forall c, d_i \stackrel{c} \rightarrow d_x, d_j \stackrel{c} \rightarrow d_y$，那么我们断定 $d_x, d_y \in p_t$，即也属于同一个等价类。

显然，这是一个约束条件。比如我们可以将每一个状态都单独归入一个等价类中，它满足上面这个约束。但我们的目的是在上面这个约束的条件下，尽可能放大每一个等价类集合 $p_s$，其中 $p_s \in P$

![v2-1f16bc9343eb1764c11d59a5823dae2a_1440w](https://src-1259777572.cos.ap-chengdu.myqcloud.com/v2-1f16bc9343eb1764c11d59a5823dae2a_1440w.png)

对于上面这个划分：$q_1$, $q_2$, $q_3$ 都有对字符 $a$ 的转移，但是 $q_1$ 和 $q_2$转移到了同样的一个状态 $S_2$, $q_3$ 转移到了 $S_3$。所以 $q_1$, $q_2$ 可以看做一组，因为它们对 $a$ 的行为是一致的，都到了 $S_2$。$q_3$ 单独一组。我们说 **$a$ 这个字符将 $S_1$ 切为了两个子集**



#### 算法

为了达到最大化分的目的，我们从最粗糙的划分开始：

- 我们首先将所有状态分为两类，可接受状态 A 与不可接受状态 N，这是因为接收状态和不可接受状态不可能在同一个等价类中

- 将他们逐渐切分到不可再分为止

```python
new = {N, A}
old = {}

while (new != old):	# 直到两个集合不再变化为止
    old = new	# 保存原切分
    new = {}	# 准备进一步切分
    for p in old:
        new = new ∪ split(p)
```

切分函数

```python
def split(S):
	for c in Σ:	# 对于任意字符 c
        if c can split S into s1 and S2:	# 运用之前的等价原则
            return {s1, s2}
    return S
```

如果对于任意字符 $c$ 集合 $S$ 都表现出同样的行为，就说明 c 无法切分 $S$；否则就说明可以切分，最多切分到一个等价类只有一个状态为止

我们当然可以将 S 切分为多个子集，但是每次只创建一个等价集合，而将其他不一致的状态划分到另一个集合其实已经够用了



#### 举例

1. 首先将整个集合划分为 $\{ \{s_3, s_5\}, \{s_0, s_1, s_2, s_4\} \}$
2. 考察 $\{s_3, s_5\}$，没有字符能区分内部的状态，所以该集合不会被拆分
3. 考察 $\{s_0, s_1, s_2, s_4\}$，对于字符 $e$，$\{s_2, s_4\}$ 针对 $e$ 可以转移到另一个等价类，而 $\{s_0, s_1\}$ 则并非如此，所以继续进行切分
4. 同样的切分  $\{s_0, s_1\}$ 为 $\{s_0\}$ 和 $\{s_1\}$
5. 最终划分为$\{ \{s_3, s_5\}, \{s_0\}, \{s_1\}, \{s_2, s_4\} \}$

![image-20221009170515678](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221009170515678.png)



### 词法分析器

#### 表驱动

表驱动的本质就是将 DFA 编码为一张状态转移表，当遇到对应字符时查表选择转移状态。

由于一般而言许多字符属于同一类别，如果将其全部编译进一张表则该表可能会很大（如 0...9 均属于数字，可能该 DFA 遇到数字时所执行的操作都是一样的），则此时可以先将字符分类，在在分类后的字符上进行状态转移表的构造



##### 算法流程

![image-20221009202540090](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221009202540090.png)

我们维护一个 stack 栈，该栈始终以最近一次遇到的接受状态为栈底（初始化 bad 为栈底，表示尚未遇到可接受单词）

我们不主动跳出 `while` 循环，而是等他接收到下一个字符后主动进入 `error` 状态，再在第二个 `while` 中手动回溯最近的可接受状态，并将指针回调（`RollBack()`）

> 之所以这样做是因为我们要完成最长匹配，所以肯定不能一遇到可接收状态就返回。
>
> 比如我们不能够把 `ifabc` 识别为 `if` 和 `abc`，而要统一识别为标识符 `ifabc`

当然也有可能我们之前根本没有遇到过一个可接收状态，这时候我们最初留在栈底的 `bad` 哨兵就会提醒我们返回 `invalid`



#### 直接编码

直接编码就是将DFA的转移逻辑直接用代码的形式呈现（不必担心过于冗杂，这些代码都是词法分析器生成器（scanner generator）生成的）

由于表驱动方法每次都需要查表，而查表带来内存开销，尤其是当表比较大的时候，可能在表中的多个状态之间切换，从而频繁引起缓存失效或者缺页，而直接编码是将 DFA 的逻辑直接用代码表述出来，用专门的代码实现每个状态，减少了内存开销

![image-20221009204652315](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221009204652315.png)

这些代码难以理解，不过我们不需要理解，我们也不会去调试它，它是由代码生成的

由于代码中大量使用 `goto` 语句，可能效果反而不如查表？



#### 手工编码

当源代码所组成的字符串过大时，我们可以使用缓冲流来进行缓存，我们一般使用双缓冲区模式。我们需要将之前的输入流暂时缓存，不能直接覆盖，否则若是回滚时需要用到之前的流而它已经被覆盖则会引起一定的困难。

如何处理关键字？许多作者建议是：先使用 DFA 将潜在的关键字定义为标识符，再测试该标识符是否是关键字。由于程序语言的关键字一般是固定的，我们使用完美散列可以达到常数级的判断





### 高级主题

#### 从 DFA 到 RE



#### DFA最小化：Brzozowski 算法



