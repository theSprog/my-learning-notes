## 全局优化

全局其实是指过程内全局，而非整个程序的全局。换句话说我们分析的是一个函数内的数据关系。

---

### reaching definition

#### 概念

- definition

  > 某一个变量 v 的 definition 是指对 v 的一次赋值，包括初始化赋值和之后的赋值

- reach 

  > 变量 v 在 p 中定义，v reach q 是指在 p 到 q 的所有路径上都没有再对 v 的 definition
  >
  > <img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221207151426771.png" alt="image-20221207151426771" style="zoom:50%;" />

- gen 集合

  > 假设某一个操作 $x \leftarrow y\ op\ z$，那么对于这个操作 $gen = gen \cup \{x\}$，即在此次生成了 `x` 变量

- kill 集合

  > 同样的操作 $x \leftarrow y\ op\ z$，这个操作也 kill 了所有其他定义 `x` 的地方，即 $kill = kill \cup \{x | x \in otherDefx\}$
  >
  > 注意 gen 和 kill 似乎都是 `x` 变量，但他们所指代的却是不同的 statement



#### 应用

- ##### 未初始化查询

我们可以在每一个过程的 entry 之前加入一个 dummy head，里面放入在这个过程中所涉及到的变量的**伪初始化**，如果这个伪初始化的变量 reach 到了某处 use 它的地方，说明我们使用了伪初始化的变量，即对外 report 变量**未初始化**

这是一个 may analysis，因为程序可能有若干条路经，但凡有一条路径使得未初始化的变量 reach 到 use 的地方都应该报错（因为程序运行时 **may** 运行这条路径）



#### 算法

假设我们的算法没有别名，同时不涉及过程调用，至于为什么会在之后的缺陷讲解。

<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221207163450635.png" alt="image-20221207163450635" style="zoom:80%;" />

- 首先初始化分为两块，

  - 每一个过程的入口之前都有一个逻辑上的 entry 结点，它并不在代码中存在但是为了给每一个过程统一入口点，都会假设每个过程有一个虚拟的入口。同样的也有一个统一的出口
  - OUT[entry] = $\empty$ 表示没有任何 definition 到达此处，因为 entry 内部甚至都没有指令，而且它只有出口，没有入口，自然不存在 definition 到达
  - OUT[B] = $\empty$ 初始化为空集合

- 迭代数据流分析

  - 对于 reaching-definition 分析，每一个基本块的 IN 都是前驱的交集
  - 每一个基本块的 OUT 都遵循 Transfer 公式

- 算法的终止性

  > gen 和 kill 都是固定的，IN 不变时 OUT 必然不变。对于 IN 而言，一旦其中的某个元素 $e$ 没有被 kill，那么在之后的迭代中它也不可能被 kill。
  >
  > 换句话说，整个 OUT 的变化具备单调性，只能单调递增，而不可能变小，而 OUT 又是有上限的，所以 OUT 必然会停止在某一个状态，此时整个算法停止。
  >
  > 整个算法最关键的灵魂在于：IN 不变 OUT 就不变， OUT 不变 IN 就不变。学术化的说：算法到达了不动点（fixed point）



#### 缺点

这个方法可用于检测未初始化变量。但由于现代程序的复杂性，也有可能会出现假警报：

- 如果 `v` 可以通过别名访问，那么有可能通过别名进行初始化。没有别名分析的 reaching-definition 可能会对这种情况误报

  <img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221207165210394.png" alt="image-20221207165210394" style="zoom:80%;" />

- 如果 `v` 在访问前就存在了，那么它可能用当前过程无法感知的方式初始化过了。例如静态变量或者当前作用域之外的变量

- 如果某条路经本身就是不可能的，那么在该路径上得出的未初始化自然就是误报了

  <img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221207165514962.png" alt="image-20221207165514962" style="zoom:67%;" />

  > 对于上面这个程序，由于在循环的第一次时 `i==1` 从而必然触发 `s`的初始化，所以不可能出现越过 `if` 从而直接使用 `s` 的情况。然而单独的 reaching-definition 不会考虑这些情况



---

### live variables

#### 概念

众所周知，很多编程语言中的变量是有寿命的。当程序执行到后面，有些先前使用过的变量就再也不会被用到，此时有的语言就会将其占用的内存回收。

<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221207195132332.png" alt="image-20221207195132332" style="zoom:67%;" />

如果程序点 **p** 处的变量 **v** 可以在CFG图中，以 p 为起始点的某条路径中被使用，则称其在程序点 **p** 上 **live**，否则为**dead**。

> 通俗来说，live variables 是指如果变量 v 在位置 p 存活，意味着 v 可能在 p 之后会被用到。反之，如果 v 在 p 不存活，表示对于 p 以及之后的语句，v一定不会被用到



#### 应用

- ##### 未初始化查询

对于过程的 CFG 图，我们只要算出虚拟的 entry 结点的 live set，那么这里面的所有值必然都是未初始化的值。因为根据定义从该结点到某个 use 处不存在其他 define，所以 entry 的 live set 必然是未初始化的变量

- ##### 寄存器分配

当我们想要分配一个寄存器的时候，发现寄存器都全部被前面的变量占用。这时候编译器想要释放一个寄存器，就需要知道，哪些变量从当前位置到程序结束，都不再会被用到。如果发现这种变量那么就可以将它优先从寄存器中释放。

- ##### SSA 构建

在某个值已经 dead 的地方不用插入 $\phi$ 函数，这样可以显著减少构建 SSA 时必须使用的 $\phi$ 数目



#### 算法

live variable 一般采用 backward 方式求解，因为看一个变量有没有被使用最好就是从后往前看。从后往前传播定义（def）使用（use）信息。

如下面的代码所示，如果从前往后，那么要想查询变量 a 是否在 line 3 存活必须要一直扫描到程序结尾才能确定

```python
a = 1
print(a)
b = 2
print(b)
```

反向扫描更加直观：从最后一行代码开始。此时所有的variable都已经 dead。然后随着算法的进行，我们会逐渐发现某些变量在某些位置是不能在是 dead，必须设置为 live。例如上面的 `print(b)` 时 `b` 一定不能是 dead。

<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221207200737440.png" alt="image-20221207200737440" style="zoom:80%;" />

- 由于是 backward，因此是给定 OUT 求 IN。初始化也是初始化 IN 集合

  > exit 结点所有的变量都是 dead，因为在此之后没有 statement，自然不可能会有 use 变量的地方

- 而 OUT 也是来自于后继的 IN 集合的 union

- IN 集合的含义就是变量到达此处时需不需要将其设置为 live。如果之后不可能使用，则当然不需要将其设置为 live，保留为 dead 即可。换句话说就是不断询问：到此处变量有 live 的必要么。

  > 如果该变量被 use 当然需要将变量复活（也就是设置为 live）。但其实从另一个角度看。如果一条语句本就定义了该变量，那么即使它在之前是 dead 的也无妨，因为反正在本语句也会再 define。
  >
  > 典型的 BB：
  >
  > ```python
  > v = 2
  > k = v
  > ```
  >
  > 这里我们发现我们可以把 IN 设置为 $\empty$，这是因为即使在之前 v 是 dead，那么在执行此语句后 v 也会被 define。换句话说在 IN 中 v 没有 live 的必要



#### 与到达定值分析的差异

reaching definition analysis是正向扫描的，因为那个任务的需求是看之前的变量定义是否能到达当前的位置。

而 live variable 的作用是不断查询某个变量到此处是否还有 live 的必要，或者说我们是否可以将其设置为 dead。类似于对变量的生命周期的分析



---

### available expression

#### 概念

该算法是 must analysis，换句话说 under-approximate 。

`x op y` 在程序点 p 是 available  必须满足两个条件：

- 从entry 到 p 点的**所有 path** 必须经过`x op y`
- 最后一次使用`x op y`之后，没有重定义操作数x、y

之后会使用算法描述如何同时满足这两个规则。



#### 应用

检测全局公共子表达式用于优化，如果我们能在编译期间知道某些公共子表达式形式必然相等，那么我们可以直接将第一次计算后的值赋值给之后使用处，甚至如果这是一个常量表达式我们还可以在编译期间计算出结果。



#### 算法

<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221207210658027.png" alt="image-20221207210658027" style="zoom:67%;" />

当经过 statement 时

- kill

  > 需要 kill 掉所有包含 redefine 的表达式，如上图的包含 a 的 expr `a + b`

- gen 

  > 需要生成新的表达式，如上图的 `x op y`

<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221207212153463.png" alt="image-20221207212153463" style="zoom: 67%;" />

- 该算法是一个 forward 算法。
- 该算法不于之前在于在汇聚时是做交集 $\cap$ 。而之前的算法是做 $\cup$ 。这是因为该算法是一个 must analysis，必须在所有 path 都具有相同 expr 时才能优化。这就体现为 $\cap$。
- OUT[B] 是 U，即所有表达式



#### 一个误区

对于下面这个 CFG，最后的 $c = e^{16} * x$ 实际上是 available 的，尽管似乎在左边路径上 `x` 的值已被改变。

但最后计算 c 时总是采用最近计算的那个 $e^{16} * x$ 表达式，而这个表达式只用计算一次（不管他是来自左边还是右边）

<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221207211427691.png" alt="image-20221207211427691" style="zoom:67%;" />





### 全局代码置放

一般而言落空分支（fall through branch）的代价要小于采纳分支，因为分支意味着跳转。而如果落空分支是一个短跳转，那么就能很好得利用缓存。

<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221208132359502.png" alt="image-20221208132359502" style="zoom:67%;" />

对于上图，如果程序 $B_0, B_2, B_3$ 被采纳的频率远大于 $B_0, B_1, B_3$，那么编译器可以采用右侧的那种布局，使得 $B_2$ 近邻 $B_0$ 从而有很大的可能缓存命中，提升效率。

如果编译器能在编译期就知道各个分支的执行频率，就能够采用一种最优化的代码布局提升运行时性能。

代码置放具有独立的分析和变换阶段。分析阶段收集分支执行频度数据，变换阶段利用这些数据来对基本块进行排序。可以看出，该优化需要程序运行时信息，是一种运行时优化。

> 一个运行时优化器可监视程序的执行，收集有关应用使用模式的描述信息。 从应用行为检测到的优化机会，能引发运行时再优化器动态地重新编译和再优化应用的部分



#### 数据采集手段

- 装有测量机制的可执行文件。

  > 编译器往生成的代码中插入统计信息代码，如进入和退出过程或采纳分支等。在运行时，数据被写出到一个外部文件，由另一个工具离线处理。

- 定时器中断。

  > 定时器以较高的频率中断程序的执行（stop the world），统计中断时程序计数器 pc 的位置，以此为依据判定路径频率。

- 性能计数器。

  > 如果处理器提供硬件计数器来统计事件，如处理器周期数，缓存失效或采纳分支，则可直接使用。但这种方式依赖于特定的处理器架构



#### 算法

该算法实际上就是不断遍历各条边，如果一个边两边的结点组成的链满足合并条件，就将它们合并。当所有的边遍历完后就得出链集合，根据链集合排序代码。

<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221208135508337.png" alt="image-20221208135508337" style="zoom:80%;" />

- 首先将所有结点视为一个链，换句话说每一条链都是单个节点。并且初始化每一条链的优先级为一个大数。比如可以初始化为 $|edges|$。
- 然后按照执行频率递减的方式逐渐遍历各条边：如果一条边的两个结点所对应的链能够合并（即算法中的 `if`，一个节点是链头，一个节点是链尾），则将链合并并更新优先级。



#### 举例

<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221208135455900.png" alt="image-20221208135455900" style="zoom:80%;" />



- 对于上面的 CFG，首先初始化链为单个 BB，然后根据执行频率降序排序边处理顺序。

> <img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221208140748033.png" alt="image-20221208140748033" style="zoom:67%;" />

- 首先处理 $(B_0, B_1)$，由于可以合并（$B_0$ 是链的尾部，$B_1$ 是链的头部），更新链的优先级为 min( $B_0$,$B_1$,$P++$)。
- 然后再处理 $(B_1, B_5)$，$(B_3, B_5)$，$(B_4, B_5)$，这其中只有 $(B_1, B_3)$ 会更新链
- 然后是 $(B_0, B_2)$，$(B_2, B_4)$，其中 $(B_2, B_4)$ 会合并出新的链
- 最后是 $(B_1, B_4)$



#### 代码布局

布局的思想其实很简单：

- 一个链内部的基本块按照顺序放置，使得链中的边处于落空分支。
- 而多个链之间按照链的优先级顺序放置，由低到高

<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221208143136785.png" alt="image-20221208143136785" style="zoom:80%;" />



<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221208143501286.png" alt="image-20221208143501286" style="zoom:80%;" />

从包含 $B_0$ 的链开始，放置 $(B_0,B_1,B_3,B_5)$，然后由于存在边 $(B_0, B_2)$ $(B_2, B_4)$ $(B_1, B_2)$ 和 $(B_4, B_5)$ 所以将涉及到的 $B_2, B_4$ 的链加入 worklist 中。