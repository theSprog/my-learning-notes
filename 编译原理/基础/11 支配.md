## 支配

编译器推断 CFG 性质的一个重要工具就是支配性（domain）

> 定义：
>
> 从结点 entry 到 $B$ 的所有路径上都存在结点 $D$，那么称为 $D$ 是 $B$ 的支配者。根据定义，$B$ 自己是自己的支配者



### 支配公式

$$
\operatorname{Dom}(n)=\{n\} \cup\left(\bigcap_{m \in \operatorname{preds}(n)} \operatorname{Dom}(m)\right)
$$

这个公式的本质就是将一个结点从入口到它的所有路径作交集。并且传递计算。

初始条件如下：
$$
Dom(n) = \left\{ 

\begin{array}{rcl}
\left\{n_{0}\right\} 	& n = {n_{0}}	\\
N						& \forall n \neq n_{0}
\end{array}

\right.
$$
其中 $N$ 是全 CFG 中所有结点的集合，换句话说除了入口结点其他结点全部初始化为全集。



### 算法

<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221208153832709.png" alt="image-20221208153832709" style="zoom: 80%;" />

- 该算法一定会停止

  > 这是因为计算 Dom 集合的过程是单调递减的，而 Dom 集合最少只能有一个结点，因此每一个 Dom 都会最终达到一个下界，此时 Dom 集合不再改变，算法跳出循环。

- 正确性

  > 当且仅当所有的前驱都包含结点 $k$ 时它才是本结点的支配结点。迭代算法的不动点理论向我们保证，这个特定的方程具有唯一的不动点

- 效率

  > 虽然算法的活性（不会死循环）和正确性（解必然正确）
  >
  > 迭代过程的顺序不同，效率也会大不相同。对于很多数据流分析问题而言，我们可以对求值过程进行适当排序，使算法经过很少的迭代就能收敛
  >
  > 一般而言，对于正向（forward）数据流问题，应该采用图的逆后序（reverse post order，RPO）遍历。因为他会尽可能访问结点的前驱。
  >
  > 而对于反向数据流问题，应该在 CFG 上采用后序遍历，因为它会尽可能访问一个结点的后继。



## 支配边界

### 定义

支配边界可以用于精准定义一个基本块所需要的真正的 $\phi$ 函数，在支配区域以外的结点才需要插入 $\phi$ 函数

假设结点 n 和 m，m 是 n 的支配边界满足两个定义：

- n 支配 m 的前驱

- n 不严格支配 m

  > 严格支配性：当且仅当 $a \in Dom(b) - b$ 时我们说 $a$ 严格支配 $b$ 
  >
  > 之所以使用严格支配性是因为如果一个基本块自身构成循环，那么可以在该基本块头部插入 $\phi$ 函数，因为这一个块支配自身（自身作为自身的前驱），同时自身又不严格支配自身。

对于下面的例子，由于 $B_5$ 支配 $B_3$ 的前驱 $B_7$，同时 $B_5$ 并不支配 $B_3$（$B_5$ 不是到 $B_3$ 的必经之路）。所以我们可以说 $B_3$ 是 $B_5$ 的支配边界，简记为 $DF(B_5) = \{B_3\}$

**通俗的说，$DF(B)$ 就是离开 $B$ 支配领域之外的第一个结点**。

> 严格支配 n 的结点是 $Dom(n) - n$ ，在这些结点中与 n 直接相邻的结点是直接支配结点，被记为 $IDom(n)$。流图的入口没有直接支配结点，因为它没有严格支配集。



<div style="display:flex; flex-direction:row; justify-content:space-around">
	<div>
		<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221208190325129.png" style="zoom:85%;"/>
		<center><b>(a)</b></center>
	</div>
	<div>
		<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221212135625031.png" alt="image-20221212135625031"/>
		<center><b>(b)</b></center>
	</div>
</div>



### 支配者树

> 直接支配结点：如果 $m$ 是 $Dom(n) - n$ 的结点之一并且离 $m$ 的距离最近，则被称为直接支配结点，记为 $IDom(n)$。

支配者树是由每个结点的 $IDom$ 信息构建的，每个结点都将其直接直接支配结点作为其父结点，因此形成一棵树，该树叫做支配者树。从支配者树中我们可以立即得到一个结点的支配结点（只需要查找其父即可）

例如上图中的 CFG 图，其支配者树为图（b）



### 算法

求解支配边界的算法如下：

我们将其表述为一个数据流问题，不断遍历本结点的前驱以及其直接支配结点（以 `runner` 表示），查看本结点是否能够放入这些 `runner` 节点的支配边界中。

不能放入的条件是，`runner`  结点是本结点的直接支配结点。而在其中查找路径上的结点则不能支配本结点（因为按照定义，直接支配结点就是最近的支配结点，自然不可能存在比它还近的支配结点），则可以将本结点放入这些结点的支配边界中。

![image-20221212135923685](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221212135923685.png)

- DF 中的结点必定是汇合结点，只有这些结点才有多个前驱结点。所以我们只需要处理这类节点即可
- 对于这类结点的前驱节点，我们将本结点加入到前驱结点的支配边界中（除非该前驱本就是在直接支配结点中）。
- 直到我们前进到本结点的直接支配结点时，该结点处理完毕



对于下面这个例子：

<div style="display:flex; flex-direction:row; justify-content:space-around">
	<div>
		<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221208190325129.png" style="zoom:85%;"/>
		<center><b>(a)</b></center>
	</div>
	<div>
		<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221212135625031.png" alt="image-20221212135625031"/>
		<center><b>(b)</b></center>
	</div>
</div>

- 首先，该 CFG 中有多个前驱的结点分别是 $\{B_1, B_7, B_3\}$
- 对于 $B_1$ 而言：
  - 其前驱 $B_0$ 是其直接支配结点，跳过。
  - 前驱 $B_3$ 满足条件，可以将 $B_1$ 加入到 $B_3$ 的支配边界中。
  - 然后从 $B_3$ 继续回溯，达到 $B_1$，它不是 $B_1$ 的直接支配结点，所以将 $B_1$ 加入 $B_1$ 的支配边界中。
  - 然后从 $B_1$ 继续回溯，达到 $B_0$，它是 $B_1$ 的直接支配结点，跳过
- 对于 $B_3$ 而言：
  - 其前驱 $B_2$ 满足条件，将 $B_3$ 加入 到 $B_2$ 的支配边界中。
  - 然后从 $B_2$ 继续回溯，达到 $B_1$，它是 $B_3$ 的直接支配结点，跳过
  - 其前驱 $B_7$ 满足条件，将 $B_3$ 加入 到 $B_7$ 的支配边界中。
  - 然后从 $B_7$ 继续回溯，达到 $B_5$，将 $B_3$ 加入 $B_5$ 的支配边界中
  - 然后从 $B_5$ 继续回溯，达到 $B_1$，它是 $B_3$ 的直接支配结点，跳过
- 对于 $B_7$ 而言：
  - 其前驱 $B_6$ $B_8$  满足条件，分别将 $B_7$ 加入两者的支配边界中。
  - 然后都来到 $B_5$，$B_5$ 是当前结点 $B_7$ 的直接支配结点，跳出。

最终的结果为

![image-20221212143712108](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221212143712108.png)