## 使用 SSA

我们在 SSA 上使用一种名为稀疏简单常量传播的算法（sparse simple constant propagation，SSCP）



## 符号

![image-20221214160540193](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221214160540193.png)

## 算法

整个算法就是在格上不断下降的过程：

> $$
> \begin{array}{ll}
> \top \wedge x=x & \forall x \\
> \bot \wedge x=\bot & \forall x \\
> c_{i} \wedge c_{j}=c_{i} & \text { if } c_{i}=c_{j} \\
> c_{i} \wedge c_{j}=\bot & \text { if } c_{i} \neq c_{j} \\
> \end{array}
> $$

![image-20221214160531025](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221214160531025.png)

- 初始化阶段会遍历各个静态单赋值形式名 `n`，如果：
  - `n` 是由 $\phi$ 定义的，则将 `value(n)`  设置为 $\top$
  - `n` 被定义为一个常量 $c_i$ ，则将 `value(n)` 设置为 $c_i$
  - `n` 是由外部给定，则将其定义为 $\bot$，意为不可能为常量
  - 对于不是 $\top$ 的值全都加入 worklist 中
- 假设 `n` 被用于计算 `m`：$m = op(n)$，如果 `m` 不是 $\bot$，算法会将 `op` 重新解释并且对 `value(m)` 赋值，格点运动规则如之前所示



## 性质

### 可停止性

每次传播只能在格上只能调低其值，而这种调整最多只有两次，从 $\top$ 到 $c_i$ 和 从 $c_i$ 到 $\bot$ ，因此单调下降同时有界，不同点存在。该算法的效率至多只能是所有值的两倍，即 $O(2n)$



### 乐观性

算法将未知值初始化为 $\top$ 而非 $\bot$ 这其实是一种乐观性，该初始化指望在后面该值可能会下降为常数。如下图所示

![image-20221214163928142](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221214163928142.png)

如果将 $x_1$ 和 $x_2$ 设置为 $\bot$ ，则 $x_0$ 无法被传进循环中，在对 $x_1 = \phi(x_0,x_2)$ 进行求解时，有 $17 \wedge \bot = \bot$，因此 $x_2$ 也被计算为 $\bot$，即使在 $i_{12}$ 是 $0$ 也是如此

相反，如果将 $x_1$ 和 $x_2$ 设置为 $\top$，则 $x_1$ 会被求解为常数 17，假如 $x_1 + 0$ 则 $x_2$ 被求解为常数 17。之后的每次循环都是如此，因此 $x_1$ 和 $x_2$ 被求解为常量，可以继续向后传播。换句话说此时比设置为 $\bot$ 更加准确（虽然设置为 $\bot$ 也是 sound 的）。

当然，假如 $i_{12}$ 不是 0，那么在循环之后求解 $x_1 = \phi(x_0, x_2)$ 同样也会将 $x_1$ 再次求解为 $\bot$，不会损失 sound。

总之，将 $\phi$ 初始化为 $\top$ 和 $\bot$ 都是合理的（都能够到达不动点，虽然两个不动点不同），但是初始化为 $\top$ 更加准确一点，两者都是 sound 的



### 简单性

在静态单赋值形式中，传播步骤是稀疏的，因此很快就能达到不动点，因此称为 sparse simple。在这种操作中只有 $\phi$ 函数才使用 meet 操作



