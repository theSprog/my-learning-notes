### 类型系统简介

- 强类型

  > 一个表达式只能够被解释为一种无歧义类型

- 弱类型

  > 一个表达式只能够被解释为多种类型，例如 C 的 void* 转换
  >
  > ```c
  > int a = 0;
  > int* b = (int*) a;
  > ```
  >
  > 另外：也有人认为 C 是强类型（挠头。。。）

- 静态类型

  > 在编译期间就能够确定类型，如 Java， Rust

- 动态类型

  > 必须要等程序运行期间才能确定类型。运行时类型检查要求为值的类型提供一种运行时表示，因此每一个变量不仅有 value 字段，还要有 tag 字段用以为值标注类型。
  >
  > 对 value 所进行的操作是否合法，以及如果合法那具体是执行哪一个过程依赖于 tag 字段

- 无类型

  > 例如 $\lambda$ 演算，汇编语言

![b0aeb7ffd1667b9162e5329154d43777_1440w](https://src-1259777572.cos.ap-chengdu.myqcloud.com/b0aeb7ffd1667b9162e5329154d43777_1440w.png)



---

### 类型系统组件

#### 基础类型

- 数字

  > 包括整数，浮点数，有些语言还区分了有符号和无符号等

- 字符

  > 一个字符根据语言所选字符集和实现该字符集的方式可能有不同的内存占用，例如：
  >
  > - C 的 char 由于支持 ASCII 字符集，所以只需要 1 个字节存储
  > - Java 由于支持 UTF-16 的 Unicode 编码，所以 char 占两个字节
  > - Rust 采用 UTF-32 编码，固定4个字节长度

- 布尔值

  > 有些语言将布尔值映射到 0 和 1



#### 复合类型和构造类型

- 数组

- 串

  > 包括位串和比特串

- 枚举

  > 编译器将 enum 各个成员映射为不同的、可比较的值。比较同一枚举内的值是有意义的，而不同枚举间的值没有意义

- 结构体、类

- 指针

  > 指针包含两块信息：一块是引用对象的地址，另一块是该对象的类型



#### 类型等价

下面两个结构是否等价：

```c
struct A {
    int a;
}

struct B {
    int b;
}
```

- 命名等价性

  > 两个类型等价的充要条件是他们必须同名，对于别名类型，视为不等价
  >
  > ```c
  > typedef int bool
  > ```
  >
  > `int` 和 `bool` 不等价
  >
  > 缺点：问题是在大项目中可能出现名字冲突，如果冲突是无意识的有可能使编译器错误判断类型等价性

- 结构等价性

  > 类型等价的充要条件是他们具有相同的结构：字段排列顺序相同，且对应字段具有等价的类型
  >
  > 缺点：有时我们可能确实需要同一结构表示不同的类型，如 `int` 和 `bool` 应该具有**不同的语义**。我们不能给 `bool` 赋值为数值，同理不可以给 `int` 赋值为 `True` 或者 `False`。但结构等价性却允许这么做



#### 类型推断

- 函数原型

  > ```c
  > int f(char* s);
  > ```
  >
  > 它包含入参和反参，以及该函数的名称。尽管并没有给出一个实现





---

### 属性语法和语法制导翻译

之前的语法分析只是单纯地判断输入流是否符合语法规范，然而语法分析真正地目的在于生成一颗抽象语法树（AST）。属性语法和语法制导翻译就是将之前形式上的处理逻辑变为代码形式，最后生成 AST。

除此之外，可能还要附加其他的工作：

- 类型检查
- 语义推敲
- ...

这些工作基本都可以通过属性语法和语法制导翻译完成。



#### 属性语法

所谓属性语法就是将语法中每个符号的属性（常见的包括值，类型，存储地址等）和符号关联起来，将符号与符号之间的计算规则和上下文无关文法绑定到一起，这样形成的新文法（基于上下文无关文法的扩充）就是属性文法。

比如说构建语法分析树：
$$
E_0 \rightarrow E_1 + E_2  \left\{ 

							\begin{array}{l}
							E_0.node = new \ node(); 	\\
							E_0.type = plus;			\\
							E_0.node.left = E_1.node; 	\\
                            E_0.node.right = E_2.node;
                            \end{array}
                            
                            \right\}
                            
                            \\
E \rightarrow n 			\left\{ 

							\begin{array}{l}
							E.node = new \ node();		\\
							E.type = constant;			\\
							E.value = n;				\\
                            \end{array}
                            
                            \right\}
$$
我们在进行规约时，就会去执行产生式右侧的语法规则。或者在进行推导时，当递归返回则去执行右侧规则。当整个推导或者规约完成后，整个语法分析树就构建完成。

**当然这其中包含大量无用的符号信息，而之后的工作可以将语法分析树精简为抽象语法树：**

<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221021211816072.png" alt="image-20221021211816072" style="zoom:67%;" />

根据 AST 我们可以轻易生成汇编代码（此处假设无限寄存器）
$$
\begin{array}{l}
load \ a \rightarrow r_1	\\
loadi \ 3 \rightarrow r_2	\\
mul \ r_1, r_2 \rightarrow r_3	\\
load \ b \rightarrow r_4	\\
add \ r_3, r_4 \rightarrow r_5	\\
store \ r_5 \rightarrow x		\\
\end{array}

$$
现在我们的问题是：怎么从文法和输入流构建解析树，然后从解析树构建 AST。或者说我们可以直接构建 AST



##### 符号属性

- 综合属性

  > 非终结符的综合属性只能来自于其子节点或者来自于其自身。简而言之就是把子节点综合起来（来自于自身被视为一种特殊的综合）
  >
  > 
  >
  > 终结符结点也可以有属性，只不过由于不涉及对终结符的规约或者推导，其属性只是简单来自于词法分析器提供的词法值

- 继承属性

  > 非终结符的继承属性只能来自于其父节点、兄弟节点和其自身。比如常见的声明语句（`int a;`）
  > $$
  > D \rightarrow T\ I;
  > $$
  > 标识符 $I$ 能有什么类型完全依赖于其兄弟结点 $T$，因此 $I$ 的类型是一个继承属性





#### 语法制导翻译

属性语法中包含大量属性，很容易造成属性膨胀；而且属性流动也不固定，可能由子节点向父节点，也有可能相反，甚至可能由兄弟节点决定。这些限制了属性文法的使用。

语法制导翻译的规则简单许多，值（value）只能由子结点流向父节点（属性文法没有规定求值顺序），而且符号只有一个 value 属性。每次在规约时都可以先执行对应操作。（语法制导翻译只有一种求值顺序，即后序遍历语法解析树）

语法分析器生成器可以将这些操作收集起来，统一通过 map 保存，其中 key 是产生式编号，value 是产生式所对应的操作。

![image-20221022155645837](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221022155645837.png)



建立抽象语法树 AST 规则：

- 对于运算符，建立一个节点表示运算符本身，并且将所有操作数连接为其子节点。
- 对于无用产生式，如 $Term \rightarrow Factor$，仅仅重用 $Factor$ 返回的结果，作为其自身的结果



AST 解析：

https://astexplorer.net/



#### 设计要求

抽象语法树是编译器前瑞和后瑞的接口，程序一旦被转换成抽象语法树，则源代码即被丢弃，后续的阶段只处理抽象语法树。

所以抽象语法树必须偏码足够多的源代码信息。例如，它必须编码每个语法结构在源代码中的位置 (文件、行号、列号等)，这样，后续的检查阶段才能精确的报错。
