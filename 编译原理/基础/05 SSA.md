### SSA

在 SSA 中，一个名字对应代码中特定的定义位置。或者说，每个变量只能被定义且赋值一次。
$$
\begin{flalign*}{}
& a \leftarrow 1		\\
& b \leftarrow a + 5	\\
& a \leftarrow 2		\\
& c \leftarrow a + 3	\\
\end{flalign*}
$$
可以看出，上面的 $a$ 被赋值了两次，违反了 SSA 定义，我们需要将其修改为
$$
\begin{flalign*}{}
& a_1 \leftarrow 1		\\
& b_1 \leftarrow a_1 + 5	\\
& a_2 \leftarrow 2		\\
& c_1 \leftarrow a_2 + 3	\\
\end{flalign*}
$$
这样一来就相当于给了每次赋值一个标号（label），可以根据此标号查找该变量是在那里被赋值的，$a_1, a_2$ 这些可以被称作 $a$ 的一个版本，这样一来对于 $a$ 的一个使用是在哪里被定值的就可以十分清楚了，可以让很多优化变得简单。



那么如果是类似于下图这样的CFG该怎么办呢？

![ssaMerge](https://src-1259777572.cos.ap-chengdu.myqcloud.com/ssaMerge.svg)

在对 $B1$、$B2$ 的 $a$ 分别进行重命名之后会产生类似于下图这样的结果，此时 $B3$ 的 $a$ 应该是哪一个引用

这个时候为了解决这个问题，可以定义一个叫做 $\phi$ 函数（phi function）的特殊指令，如在 $B3$ 的入口处插入了一条$\phi$函数，其中新定义了$a$的新的 版本 $a_3$，在随后对$a$的使用被改写为使用$a_3$

![ssaMerge3](https://src-1259777572.cos.ap-chengdu.myqcloud.com/ssaMerge3.svg)

加入了$\phi$函数的基本块有几个前驱，$\phi$函数就有几个参数，每个参数对应了一个前驱。

> 如果是从第一条边到达的基本块$B$，那么$\phi$函数返回第一个参数，如果是从第二条边到达了基本块$B$，那么$\phi$函数返回第二个参数，以此类推。

当然，事实上在计算机中找不到可以对应$\phi$函数的指令，所以需要在完成了优化之后将$\phi$函数进行去除。这里假设所有的$\phi$函数都是同时被执行的，所以不会产生顺序依赖问题，不过实际上可能会产生顺序依赖的问题，不过这个问题留到后面再来说明。

上面的内容可以说明“静态单赋值形式”中单赋值的含义，那么静态呢？静态和动态相对，比如在下面的代码中，对 a 是静态单赋值的，在IR代码中对 a 的赋值只有一次。尽管这是一个循环，在实际执行中a会被赋值多次。

```assembly
Label:
	a <- 10
	jump Label
```



### 构建

普通的IR转化为SSA形式的IR可以分为两步

- 首先在**必要的**位置插入 $\phi$ 函数，这样就会得到类似于 $x=\phi (x,x,x)$ 的语句，可以看出这里面还有很多重复的 $x$
- 第二步是对所有的变量进行重命名，将类似于 $x=\phi (x,x,x)$ 的语句转为类似于 $x_4=\phi (x_1,x_2,x_3)$ 的语句。



### 插入$\phi$函数

那么如何确定需要在哪些基本块的开始处插入哪些 $\phi$ 函数？支配性发挥着重要作用。

假设 $DF(B)$ 是 $B$ 的支配边界，$D$ 就是支配边界的一个块

如果基本块 $B$ 对变量 $v$ 进行了定义，那么在每个$D\in DF(B)$前需要插入一个$v=\phi (v,...)$，这么做的原因是因为 $D$ 的某些前驱一定会经过$B$，但是 $D$ 的另外一些前驱不一定经过$B$，那么对于 $v$ 中的值就会有冲突，所以就需要一个$\phi$函数。

不过事情不完全如此，有的时候 $\phi$ 函数是多余的，比如说被定义的 $v$ 是一个局部的，并没有被其他基本块使用，这个可以通过查看基本块的 $LiveOut$ 进行判断。如果一个变量没有存在于 $LiveOut$ 集合，那就说明后面不会使用它。



### 重命名

在插入了$\phi$函数后，需要进行重命名，进行重命名的时候需要对当前变量的version进行追踪，这里可以使用栈来进行，此处给出了一个算法：

![image-20221024205249745](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221024205249745.png)

这个算法的大致过程是在支配树上做先序遍历，然后对每个基本块内的指令进行遍历，如果出现了对一个变量 $v$ 的定义，无论是在 $\phi$ 函数进行定义还是在运算进行定义，都将产生一个新的 version，并将新的 version 推入栈中。

遍历了基本块的所有指令后如果有后继基本块且后继基本块的开始处有 $\phi$ 函数，那么对那些 $\phi$ 函数进行填充。接下来对支配树上的结点进行递归。在返回时对栈进行出栈，恢复到进入此基本块之前的状态。

> 为什么要对支配树进行先序遍历？
>
> 因为如果存在$D=IDom(B)$，那么对于$B$中的某个类似于`x <- v + 2`的指令来说其中的$v$一定是最新的。如果在$B$的开始处有关于$v$的$\phi$函数，那么$v$的version会被更新，如果没有关于$v$的$\phi$函数，那么可以保证当前栈中的$v$的version是最新的，因为$D=IDom(B)$，那么对于任意的路径$P=D \stackrel{+}{\longrightarrow} B$ 上的结点$M$来说，不会出现任何的结点$M$满足$M \in Dom(B)$，只会有$B\in DF(M)$，那么也就是说要么不定值，要么必须产生一个 $\phi$ 函数。



### 举例

假设现在插入 $\phi$ 函数如下所示，现在我们要对其进行重命名。

![image-20221212155346293](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221212155346293.png)

假设 $a_0、b_0、c_0、d_0$ 都来自于外部

- $B_0$：

  > $B_0$ 新建了 $i$ 的一个 version，并且后继为 $B_1$，因此需要填写其中的 $\phi$ 函数，因此在 $\phi$ 中的 $a、b、c、d、i$ 被重写为 $a_0、b_0、c_0、d_0、i_0$。
  >
  > 当然，这只是填写了第一个参数，第二个参数要等处理到 $B_3$ 时才会填入，因为 $B_1$ 是 $B_3$ 的后继。
  >
  > 然后在支配树中进入其后继结点，即 $B_1$

- $B_1$：

  > 在 $B_1$ 中为  $a、b、c、d、i$ 重写新 version，其中 $a、c$ 会重写两次。
  >
  > 然后为 $B_1$ 的后继 $B_2$ 和 $B_5$ 填入 $\phi$ 函数参数。当然，两者都没有 $\phi$ 函数所以不用填写
  >
  > 然后在支配树中进入其后继结点，分别为 $B_2、B_3, B_5$

- $B_2$：

  > 同样的，重写 $b、c、d$ 并且填写后继 $B_3$ 中的 $\phi$ 函数
  >
  > 支配树上 $B_2$ 没有后继，因此弹出在这个节点中对变量的重命名版本然后回到 $B_1$
  >
  > 进入 $B_1$ 的下一个后继 $B_3$

- $B_3$：

  > 如上同理可得，重要的是由于在支配树上还有后继，因此还要进入 $B_4$，之后从 $B_4$ 返回 $B_3$ 并返回 $B_1$

- ...

重命名之后的代码形式

![image-20221212161059702](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221212161059702.png)





### 摧毁

在 SSA Form下进行了优化之后需要将 $\phi$ 函数进行去除这个过程可以叫做SSA的摧毁（destruction，叫 translate out of SSA 也行，或者是 eliminate phi function ）

一个$\phi$函数的作用是根据基本块的入边返回对应的值，比如$\phi (x_1,x_2,x_3)$，如果从第一个边进入基本块就返回$x_1$，如果从第二个边进入基本块那么返回$x_2$，以此类推，也就是说如果从第一个边进入了基本块那么$x_4\gets \phi (x_1,x_2,x_3)$等价于$x_4\gets x_1$，第二个边进入等价于$x_4\gets x_2$，也是以此类推。

那么一个直接的想法就是**将这些复制语句直接放在相应的前驱**就可以了，如下图所示，将对应的复制语句放入对应的前驱中，这里面产生了$x_4$被赋值多次的情况，但是这个阶段已经不需要保持SSA Form的性质了。

<div style="display:flex; flex-direction:row; justify-content:space-around">
	<div>
		<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/copyBefore.svg"/>
		<center><b>(a)去除&phi;函数前</b></center>
	</div>
	<div>
		<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/copyAfter.svg"/>
		<center><b>(b)去除&phi;函数后</b></center>
	</div>
</div>
<div><center><b>Fig 4</b></center></div>

这些自动生成的复制语句可以在寄存器分配阶段进行消除，也可以使用其他优化进行消除



### 关键边拆分

在对 $\phi$ 函数进行消除的时候可能会遇到下图中的情况，$B$ 存在多个前驱基本块，而 $D$ 存在多个后继基本块，如果将复制指令插入到$D$的末尾就会影响到其他无关的基本块。对于下图中黄色的边可以称其为关键边（critical edge）。

![criticalEdge](https://src-1259777572.cos.ap-chengdu.myqcloud.com/criticalEdge.svg)

那么如何对这样的情况进行处理呢？那么就需要将图中的关键边进行拆分，具体就是在黄边中插入一个新的基本块，然后将复制语句放在新加入的基本块中，这个过程的结果如下图。

![criticalEdgeSplit](https://src-1259777572.cos.ap-chengdu.myqcloud.com/criticalEdgeSplit.svg)

不过不是所有对关键边的拆分都是必要的，对关键边的拆分可能会产生大量只有几条指令的基本块而且增加了跳转语句的数量

- 有的时候多执行一条指令并不会引起任何的问题

  > 但是会引入额外的赋值操作，幸运的是这些复制在之后的优化中可以删除，例如之后的复制合并；

- 而有的时候则不行，下面有对原因进行说明

其实大多数情况下不进行关键边分割其实不会有任何问题，因为插入的复制的名字是唯一的，所以不会对其他名字的变量产生影响。



### 可能的问题

#### 复制丢失问题（Lost-Copy Problem）

有的时候必须使用关键边拆分来解决问题，如下图所示，其中存在复制折叠优化

<img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221212163814924.png" alt="image-20221212163814924" style="zoom:80%;" />

- 其中原始代码改为 SSA 形式后，进行了一次复制折叠，将对 $y$ 的引用转为对 $i_1$ 的引用。然而 $i$ 的生命周期通过这种变换延长至后面的 $z \leftarrow y + \cdots$

- 在图（c）中将 SSA 还原为其他形式后出现了赋值不正确

  > 原始代码将 $i$ 的倒数第二个值赋值给 $y$ ；然而展开后的代码将 $i$ 的最后一个值赋值给 $i_1$

- 在图（d）中引入了关键边拆分后虽然解决了这种情况，但是引入了额外的一条跳转指令。如果这是一条被频繁执行的指令那么此处会存在性能损耗

- 这类问题的关键是，如果出现了 $i_2$ 那么 $i_1$ 就不应该在之后被使用了，然而关键边拆分没有解决这类问题

- 图（e）就是这类方法的解决，引入一个额外的中间变量 $t$ 并且在 $i$ 的生命周期保留在一定范围内



#### 交换问题（Swap Problem）

这种问题会出现在类似于下图中，在将 $\phi$ 函数去除后就出现了swap problem，即两个变量都是同一个值。

原因是**在进行优化的过程中假设 $\phi$ 函数是同时执行的，所以即使出现了循环引用也没有关系**，比如在下图的中间一列就出现了循环。在还原为普通形式后 $x_1$ 和 $y_1$ 都是 $y_1$ (也就是 $y_0$) 的值，不会出现交换的情形

![image-20221212170921930](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20221212170921930.png)

使用一个临时变量可以打破这种循环，见下图。

![swapProblem](https://src-1259777572.cos.ap-chengdu.myqcloud.com/swapProblem.svg)

### 遗留问题

《Engineering a Compiler》中虽然虽然描述了这两个问题，但是没有给出解决的方法，特别是一个统一的方法对问题进行解决，好在作者的论文【1】中给出了解决的方法。这里来介绍一下解决方法，这个方法不会进行关键边分割



在Sreedhar et al.【2】的文章中提出了**phi congruence class**的概念，可以利用其性质来消除$\phi$函数，这种方式我感觉比【1】给出的的要好。除了可以减少插入的移动语句数量，在处理 lost-copy 和 swap problem 的时候并不需要去考虑特殊情况，也就是说处理它们和处理其他的情况是一致的



### 参考

【1】P. Briggs, K. D. Cooper, T. J. Harvey和L. T. Simpson, 《Practical improvements to the construction and destruction of static single assignment form》

【2】V. C. Sreedhar, R. D.-C. Ju, D. M. Gillies和V. Santhanam, 《Translating Out of Static Single Assignment Form》