### golang 编码

golang使用 utf-8 作为默认编码方式。 utf-8 是Unicode 的一种实现方式。



Unicode 完成了让世界上所有字符都有一个对应的编号的壮举，对应的编号就叫码位。对于码位有不同的编码方式，例如 utf-16 就统一使用 4 字节编码，用不到的高位就补0，无论什么字符都花费 4 字节存储。然而这种方式使得空间利用效率不高，况且我们平常一般也是使用英语频率最高，而英语字符只需要采用 1 字节就可以存储，剩下的 3 字节都浪费了。



所以为了提高利用率，就不能使用定长编码，而采用变长编码， utf-8 就是这样一种编码方式。具体而言，编码的主要困难在于解码，即划定字符边界，所以 utf-8 规定：

<img src="https://bucket01-1259777572.cos.ap-chengdu.myqcloud.com/img/202204121308384.png" style="zoom: 50%;" />

如果码位处于[0, 127]就使用 1 字节编码，且高位固定补 0；

码位处于[128, 2047]就使用 2 字节编码，且高位固定补 110，而第二字节高位补 10，这样凡是看到 10 起始的字节就可以判断它不是字符的起始；

码位处于[2048, 65535]就使用 2 字节编码，且高位固定补 1110，而第二字节高位补 10，而第三字节高位补 10



编码：

先查看需要编码的字符的编号，查出处于哪个区间，然后把码位的二进制填入对应的编码模板。例如

**世** 的码位是 19990，处于 [2048, 65535]， 而 19990 二进制为 0100 111000 010110，填入模板可得  0xE4B896。此即 **世** 的 utf-8 编码



解码

要使用 utf-8 来解码， 先查看编码的开头属于 0、110 还是 1110，如果都不是，则说明编码错误。然后将对应模板的二进制提取出来，获得码位，进而查 Unicode 表获得字符。例如

**世** 的 utf-8 编码是0xE4B896，属于第三个编码模板，将对应的二进制提取出来为 0100 111000 010110，即 19990，反查 Unicode 表可得该字符是 **世**





### golang 字符串

golang 的字符串是一个结构体，包含两个成员：第一个是一根指针，内含字符串存储地区的地址，即字符串内容；第二个是一个整数，用于表示该字符串的长度，需要注意的是该长度**不是字符个数**，而**是字节个数**。在 64 位机器上，字符串结构体占用 16 个字节，指针8字节，长度8字节.



字符串的内容可以被读取，但不能被修改，因为字符串内容是被放在程序的只读存储区的。确实需要修改内容时，可以将原来的字符串强制转换为字节切片，这种操作会为切片重新分配一段内存，并且将其内容填充为原来的字符串内容。

```go
as := "hello"

bs := ([]byte)(as)
bs[0] = 'l'
```



需要注意的是：一个符号可能不止占一个码位。例如：❤️就占两个码位，即 U+2764 U+FE0F。

golang可以用一个码位的字符做变量，但不能用两个码位的。例如：

```go
我 := 2	// √

❤️:=2	// ×
```
