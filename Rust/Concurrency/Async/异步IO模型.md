### 概念

#### 同步和异步

同步和异步是从调用者视角来看的：

- 同步：当调用者调用一个方法，如果该方法在计算出结果前不返回，则这是同步方法。换句话说调用者一直在等待调用的结果
- 异步：调用一个方法，如果该方法立马返回一个Future或者Promise对象，而不管结果是否计算完成，则这是异步方法。被调用者通过状态、通知来通知调用者。以 Future 为例，当 Future 状态为就绪态时说明该方法已完成。
- 同步与异步只是一种调用方式上的区别，后面会看到有可能会出现异步方式的同步 IO



#### 阻塞和非阻塞

阻塞和非阻塞是从程序**等待调用结果时的状态**来看的

- 阻塞：如果调用者在收到结果之前线程被挂起，则说它进入了阻塞状态（阻塞不是自旋！！！）
- 非阻塞：指在不能立刻得到结果之前，该调用不会阻塞当前线程（自旋时线程也在运行，非阻塞）





### IO模型

一个 IO 操作实际分为两个部分：**IO 请求**（1） 和 **IO 读写**（2）。

#### 同步和异步IO

同步和异步IO差别在第二步：

- 同步IO：内核态与用户态之间的数据拷贝**需要用户进程参与**（用户线程陷入内核态），在此期间应用程序属于是阻塞的
- 异步IO：内核态与用户态之间的数据拷贝**不需要用户进程参与**，IO读写操作是内核线程做的

注意：

- 阻塞IO（BIO）、非阻塞IO（NIO）、IO多路复用、信号驱动IO 都是同步IO
- 异步 IO 随平台不同而名称不同：Linux 叫做 AIO、io_uring；windows 叫做 IOCP



#### 阻塞与非阻塞IO

阻塞与非阻塞IO差别在第一步：

- 阻塞IO：发起 IO 请求的进程被阻塞
- 非阻塞IO：发起 IO 请求的进程没有被阻塞



### 一些术语

#### 阻塞IO

- 同步阻塞：在（1）阶段将自己挂起，而在（2）阶段一直要用户进程参与

- 异步阻塞：在（1）阶段将自己挂起，在（2）阶段也不需要自己参与



#### 非阻塞IO

同步非阻塞有一种最原始的操作方式，即不断轮询IO端口，询问是否读写就绪，一旦读写就绪就可以进行 IO 搬运。

但今天非阻塞IO一般都采用 IO状态事件+回调方法的方式来处理IO操作，以 Future 为例：

- 同步非阻塞：Future的就绪态表示读写就绪，此时数据仍在内核中，还需要用户线程亲自搬运（异步调用的同步非阻塞）
- 异步非阻塞：Future的就绪态表示读写完成，此时数据已经在用户态空间中





