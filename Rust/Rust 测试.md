### 测试

Rust 中的测试就是一个带有 `test` 属性注解的函数。

为了将一个函数变成测试函数，需要在 `fn` 行之前加上 `#[test]`。当使用 `cargo test` 命令运行测试时，Rust 会构建一个测试执行程序用来调用标记了 `test` 属性的函数，并报告每一个测试是通过还是失败

因为测试是在同时运行的，你应该确保测试不能相互依赖，或依赖任何共享的状态，包括依赖共享的环境，比如当前工作目录或者全局变量

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        assert!(1+1==2);
    }
}
```

`tests` 是一个普通的模块，它遵循可见性规则。因为这是一个内部模块，要测试外部模块中的代码，需要将其引入到内部模块的作用域



### cargo test

默认会以多线程的方式运行所有的测试。

如果你不希望测试并行运行，或者想要更加精确的控制线程的数量，可以传递 `--test-threads` 参数和希望使用线程的数量给测试二进制文件

```shell
$ cargo test -- --test-threads=1
```

单独的 `--` 之后的代表额外参数，例如 `--test-threads=1` 是一个参数

同时默认是不捕获输出内容的，也就是说输出内容会被忽略，我们可以使用 `--nocapture` 打印输出内容





### 单元测试

单元测试与他们要测试的代码共同存放在位于 src 目录下相同的文件中。

规范是在每个文件中创建包含测试函数的 `tests` 模块，并使用 `cfg(test)` 标注模块

测试模块的 `#[cfg(test)]` 注解告诉 Rust 只在执行 `cargo test` 时才编译和运行测试代码，而在运行 `cargo build` 时不这么做。`cfg` 属性代表 configuration



### 集成测试

为了编写集成测试，需要在项目根目录创建一个 tests 目录，与 src 同级。集成测试由于本就是用于测试的，所以不用写 `mod test` 来新建一个模块

与单元测试不同，我们需要在文件顶部添加 `use xxx`。这是因为每一个 `tests` 目录中的测试文件都是完全独立的 crate，所以需要在每一个文件中导入库。tests 目录中每一个文件都被编译为单独的 crate

注意如果测试需要某些资源，资源的根目录是项目根目录，换句话说资源从项目根目录开始查找



我们仍然可以通过指定测试函数的名称作为 `cargo test` 的参数来运行特定集成测试。也可以使用 `cargo test` 的 `--test` 后跟文件的名称来运行某个特定集成测试文件中的所有测试

```shell
$ cargo test --test <filename>
```

如果还需要精确测试该测试文件的某一个函数，可以手动指定函数名

```
$ cargo test --test <filename> -- <fn_name>
```

