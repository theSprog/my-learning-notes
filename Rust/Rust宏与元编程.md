### 宏的分类

Rust 中的宏主要分为两大类：声明宏和过程宏。

声明宏目前使用 `macro_rules` 进行创建，它的形式类似于 `match` 匹配，对于用户而言，可读性和维护性都较差。由于其存在的问题和限制，在未来， `macro_rules` 会被 `deprecated`，Rust 会使用一个新的声明宏来替代它。

使用宏时有三种使用方式：`()`、`{}` 和 `[]`





### 声明宏

Rust中函数不能可变参数，但使用宏可以接受可变的参数。

声明宏的写法类似于模式匹配，宏将一段源代码跟对应的模式进行匹配，而该模式会与特定的代码相关联。一旦模式匹配成功，传入宏的那段源代码将被关联的代码所替换，最终实现宏展开。值得注意的是，所有的这些都是在编译期发生，并没有运行期的性能损耗。

实现一个自己的 `dbg!()`

```rust
#[macro_export]
macro_rules! mydbg {
    () => {
        println!("[{}/{}/line-{}]", module_path!(), file!(), line!())
    };
    
    (for $x:expr) => {{
        println!(
            "[{}/{}/line-{}] {} = {}",
            module_path!(),	// 打印 path
            file!(),		// 打印文件名
            line!(),		// 打印行号
            stringify!($x),	// 将 $x 字符串化
            $x
        );
        $x					// 最后返回求值结果
    }};
}

let c: i32 = mydbg! {for 1+2};	// 示例输出: [mytest/src/main.rs/line-178] 1 + 2 = 3
```

使用 `#[macro_export]` 注释将宏进行了导出，这样其它的包就可以将该宏引入到它们的当前作用域中，然后才能使用。

宏中的模式匹配允许返回不同的类型，比如第一个分支返回 `()`，第二个分支返回 `$x`。

`module_path!()`, `file!()`, `line!()` 是常见的三个调试宏，用于打印用于调试的一些信息，如所属文件或行号等。

`stringify!()` 这个函数是将传入参数 `str` 化，放入静态存储区中，相比于 `format!()` 不能够格式化，但是可以接受任意字符，并且存放在静态数据区，所以生命周期为 `'static`，相比于 `format!()` 更少一道运行时开销。



#### $ 符号

在 `x` 之前我们加了一个 `$` 符号，这是声明变量的一种方式，只有前缀是 `$` 的变量才能捕获字面字符，而非 `$` 符号则只能简单的字符匹配，比如 `for` 只会一一匹配宏中的 `for` ，而 `1+2` 则会被捕获为 `$x` 并用在之后的关联代码中。



#### 类型

不像是 C 中的宏，在 Rust 中宏变量是有类型的，比如 `$x` 类型为 `expr`，即是一个表达式，如果我们不提供对应的类型那么宏会匹配失败，比如我们不可能 `mydbg!(for Self)`，因为 `Self` 不是表达式，类型匹配失败。



#### {}

由于我们需要返回表达式，所以我们将代码在 `{}` 之中又用 `{}` 括起来，从而返回一个有类型的值，如果我们不这样做的话，到时候宏展开时会匹配错乱。



#### 多次匹配

由于宏接受不定长参数，这是由他的类似于正则的匹配导致的

```rust
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```

如果要多次匹配 `PATTERN`，那么需要将其用括号括起来，并在其前面加上 `$`： `$(PATTERN),*`（`*` 表示匹配 0 次或多次）。当然类似正则的语法，`*` 可替换为 `+` 或 `?`：`+` 表示匹配一次或多次，`?` 代表前面的字符最多只可以出现一次。**需要注意的是此处的 `*` 前面的 `","` 是不可省略的，否则的话会提示匹配错误**。当然如果你是使用 `?` 那么可以不用 `,`

同样可以在之后的关联代码中使用该重复，方法为 `$(CODE)*`，对比于匹配时，此处的 `*` 前面没有 `,`。之前匹配时匹配了多少次重复，此处的关联代码也会重复对应次数。明显地，如果一次都没有匹配，那么这个关联代码重复零次，相当于不会执行。







### 过程宏

过程宏分为三类：

- `#[derive]`派生宏，可以为目标结构体或枚举派生指定的代码
- 类属性宏(Attribute-like macro)，用于为目标添加自定义的属性
- 类函数宏(Function-like macro)，看上去就像是函数调用