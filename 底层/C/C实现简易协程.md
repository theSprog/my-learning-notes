## 协程的目的

协程主要是用来实现异步的。协程就是一个可以暂停和恢复的函数。

> 异步只是一种现象，它是指函数之间的非阻塞执行，一个函数并不必等待被调用函数完成才继续向下执行。
>
> 当然，多线程是实现异步的一种手段：调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。但是多线程的线程开销也比较大，性能不佳。
>
> 同样的，函数回调也可以完成异步逻辑，但是稍有不慎便会陷入回调地狱。

协程克服了上面两种方式的缺点，性能优秀（不管是单线程协程切换还是多线程协程切换），可读性高。而且协程也可以和多线程配合使用，使得一个线程的协程可以切换到另一个线程的协程上。



## 暂停与恢复

假设某一个协程暂停后，接下来的控制流去哪里？无非有三种可能：

- 回到调用者处

  > 类似于 python 的 yield 关键字

- 回到调度器，让调度器选择一个可恢复的协程去运行

  > 类似于 go 语言，协程暂停后回到调度器。由调度器考虑协程恢复。当被暂停的协程所等待的事件完成后（例如网络 IO），它在调度器面前又是可运行的，等待被调度。事件完成往往是通过操作系统通知的，例如 select，poll ，epoll 等手段。

- 直接绕过调度器，恢复另一个协程

  > 这种情况最强大，但也最危险。我们让被暂停的协程自己选择下一个要运行的协程是谁。这种方式又称为**对称式协程**。而协程之间存在父子关系的称为**非对称协程**。

协程与多线程结合，相当于存在一个总的协程池，每个线程都从协程中取出一个可运行的协程，协程暂停后又放回这个池子里面。因此协程可以跨线程恢复



## 无栈与有栈

![image-20230215143123556](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20230215143123556.png)





## 实现

想要实现协程，无非就是实现暂停和恢复而已。由于每次恢复都不是从头恢复，而是恢复到上次暂停的地方，因此我们需要一个方式，使得协程能够记录自己停止的位置。

假设我们需要实现一个 Fibonacci 函数，每次调用它都会返回一个 fib 数。



办法也很简单，就是起一个结构体：

```c
typedef struct frame {
    int state;
	
	// 局部变量
    int a;
    int b;
    int c;

    int (*resume)(struct frame*);  // this self
} frame;
```

之后每次进入函数时都会先判断上一次暂停的状态是哪里，并恢复到对应位置。

```c
int func(frame* f) {
    switch (f->state) {
        case 0:
            f->state = 1;
            goto label0;
            break;
        case 1:
            f->state = 2;
            goto label1;
            break;
        case 2:
            f->state = 3;
            goto label2;
            break;
        case 3:
            goto label3;
            break;
        default:
            break;
    }

label0:
    f->a = f->b = 1;
    return f->a;
label1:
    return f->b;

label2:
    while (1) {
        f->c = f->a + f->b;
        return f->c;
    label3:
        f->a = f->b;
        f->b = f->c;
    }
}
```

可以看出，每一次进入该函数，都会因 `state` 的不同而恢复到不同的位置，因此每一次调用都返回不同的值。

```c
#define New(type) ((type*)malloc(sizeof(type)))
#define Init(ptr, func) {memset(ptr, 0, sizeof(*ptr)); ptr->resume = func;}

int main() {
    frame* f = New(frame);	// 申请内存空间
    Init(f, func);		// 将 func 挂载到 frame 上。

    for (int i = 0; i < 10; i++) {
        printf("%d\n", f->resume(f));
    }

    free(f);
}
```

可以看出，`func` 函数是我们自己手动写出的状态转移，而在现代编译器中，往往会用编译器自动将一个函数改装成带有判定 `state` 的形式。因此才在类似于 Rust 语言中的，编译器将函数重写为一个状态机的说法，因为 `func` 函数本质上就是一个状态机，随着时间的发生而不断转移状态。



在我们所实现的简单协程中，暂停是通过 `return` 实现的，因此也就是回到上一层，而实际上我们完全可以将其指向使用 `jmp` 指令指向调度器的入口，从而进入调度器。

同样的。恢复是通过协程帧 `frame` 来实现的，其中包含所有的局部变量，以及一个 state 用于指示现在处于何种状态。协程帧并不一定要结构体实现，也可以用栈来实现，分为 **有栈协程** 和 **无栈协程**。我们实现的协程属于无栈协程，不同的协程对应自己的结构体。

有栈协程可以直接当作栈内存，访问局部变量、递归等都可以在其上完成。普通函数在线程的栈上工作，有栈协程是在对应的栈上工作。



无栈协程常用 `asycn/await` 设计，编译器看到对应标记就会将参数和局部变量挑出来放进结构体中，并且将该函数转换为一个状态机。`await` 表示之后的语句需要等待，编译器需要在此后插入一段转移执行权的代码。无栈协程对编译器的依赖比较大，代码风格上有明显的 `async/await` 关键字。

有栈协程（例如 `Go`）会将栈和协程连带放入调度器，栈上就是该协程所保存的各种状态信息。当触发暂停时，暂停点发现自己处于有栈协程内部，此时要跳转到其他协程时就会将下一条语句地址保存起来，作为恢复的凭据。可以看出，如果协程不断递归的话，使用有栈协程更快，因为不用每个协程都生成结构体，但也有爆栈的可能，这也是有栈协程的难点。
