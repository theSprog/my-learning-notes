# DP

大问题的解依赖于小问题的计算结果，或者说之后的计算依赖于之前的计算。



## 区别

- 递归

  > 递归相当于自顶向下地求解，而动态规划是直接由小到大

- 分治法

  > 根本区别在于是否存在重复子问题，如果存在则使用动态规划，不存在重复子问题则使用分治法

- 贪心

  > 动态规划为了长远的利益会损失当前利益；贪心法永远追求当前利益最大化



## 五要素

之后每一个涉及到动态规划的题目都必须回答这四个问题：

- 状态：dp 的每一个状态的具体含义是什么

  > DP 问题状态的定义是最重要的，这直接影响到后面的转移方程和初始化方式

  

- 转移方程：dp 的大小问题之间的联系是什么



- 初始化：有哪些 dp 元素可以在初始时就确定下来



- 遍历顺序：应该以行、列、斜对角线方式遍历或者其他方式遍历？

  > 有时候我们既可以按行计算，也可以按列计算。
  >
  > 这时候由于后面的**滚动数组优化**，往往可以按数量少的方向计算：例如行多列少则按列，列多行少则按行。
  >
  > <img src="https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20230212183050235.png" alt="image-20230212183050235" style="zoom:50%;" />



- 答案：最终的答案和 dp 有什么关系



## 使用场景

- 坐标型
- 前缀型
- 背包型
- 区间型，博弈型，树型，状态压缩型



## 滚动数组

当计算某一行时只需要依赖于当前行和前一行，调换方式：

```java
old = now;
now = 1 - old;
```





# 题目

## 1. 坐标型

坐标型 DP 状态最简单：

> $dp[i]$ 表示从起点到坐标 i 的最优值/方案数/可行性
> $dp[i][j]$ 表示从起点到坐标 (i，j) 的最优值/方案数/可行性

### [数字三角形](https://www.lintcode.com/problem/109)

给定一个数字三角形，找到从顶部到底部的最小路径和。每一步可以移动到下面一行的相邻数字上。



#### 五要素

- 状态

  > $dp[i][j]$ 表示从 `triangle` 当前坐标走到底部的最短路径长度

- 转移方程

  > $$
  > dp[i][j] = min(dp[i+1][j+1], dp[i+1][j]) + triangle[i][j];
  > $$

- 初始化

  > 底部坐标到底部的长度就是其自身。
  > $$
  > dp[n-1][j] = triangle[n-1][j];
  > $$

- 遍历方式

  > 从尾行到首行，逐行从起点到对角线处遍历
  
- 答案

  >  $dp[0][0]$ 即是答案



---

### [不同路径2](https://www.lintcode.com/problem/115/)

有一个机器人的位于一个 `m×n` 个网格左上角。机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。现在考虑网格中**有障碍物**，那样将会有多少条不同的路径



#### 五要素

- 状态

  > $dp[i][j]$  表示从起点到该坐标存在多少条路径。特别地，当坐标上是障碍物时 $dp[i][j] = 0$

- 转移方程

  > $$
  > dp[i][j] = \left\{ 
  > \begin{array}{rl} 
  > dp[i-1][j] + dp[i][j-1]; 	& non-obstacle\\
  > 0 							& obstacle
  > \end{array}
  > \right.
  > $$

- 初始化

  > $dp[i][0] = 1$ 当 $i$ 及其之上没有障碍物时
  >
  > $dp[0][j] = 1$ 当 $j$ 及其之左没有障碍物时

- 遍历方式

  > 从上到下，逐行遍历
  
- 答案

  > $dp[m-1][n-1]$ 



---

### [骑士不同路径2](https://www.lintcode.com/problem/630/)

在一个 `n * m` 的棋盘中(二维矩阵中 0 表示空 1 表示有障碍物)，骑士的初始位置是 `(0, 0)` ，他想要达到 `(n - 1, m - 1)` 这个位置，骑士只能从左边走到右边。

找出骑士到目标位置所需要走的最短路径并返回其长度，如果骑士无法达到则返回 `-1`.



#### 五要素

- 状态

  > $dp[i][j]$  表示从起点到该坐标最短路径数是多少。特别地，当坐标上是障碍物时 $dp[i][j] = \infty$
  >
  > 注意此时障碍物上 $dp[i][j]$ 不能设置为 0，因为此时 0 是一个有意义的数字

- 转移方程

  > $$
  > dp[i][j] = min(\dots)
  > $$
  >
  > 某一个坐标只要不是障碍点，且左侧的四个位置只要没有越界即可拿来比较

- 初始化

  > $dp[i][j] = \infty$
  >
  > $dp[0][0] = 0 \text{ 并且 } dp[i][0] = \infty$

- 遍历方式

  > 从左到右，逐列遍历。因为骑士只能从左向右走。
  >
  > 如果逐行遍历可能出现左下方某一行还未处理，因此不能计算当前状态的情况

- 答案

  > $ans = -1 \ or\  dp[n-1][m-1]$，取决于 $(n-1,m-1)$ 是否可达



---

### [炸弹袭击](https://www.lintcode.com/problem/553)

给定一个二维矩阵, 每一个格子可能是一堵墙 `W`,或者 一个敌人 `E` 或者空 `0` , 返回你可以用一个炸弹杀死的最大敌人数. 炸弹会杀死所有在同一行和同一列没有墙阻隔的敌人。 由于墙比较坚固，所以墙不会被摧毁



#### 五要素

- 状态

  > 分为四个方向：
  >
  > dpUp 表示如果将炸弹放置在该处，向上可以炸死多少人。
  >
  > dpBottom、dpLeft、dpRight 同理。
  >
  > 注意：我们假设墙和敌人处也可以放炸弹，具体的处理之后再详细展开

- 转移方程

  > $$
  > dpUp[i][j] = \left \{
  > \begin{array}{lr}
  > dpUp[i-1][j] & empty	\\
  > dpUp[i-1][j] + 1 & enemy	\\
  > 0	& wall	\\
  > \end{array}
  > \right.
  > $$
  >
  > 之所以要将敌人处也可以放置炸弹，就是为了通过 dpUp 将炸弹杀死人数传递下去。

- 初始化

  > 对于 dpUp 而言：初始化第一行，除了敌人坐标，都初始化为 0
  >
  > 对于 dpBottom 而言：初始化最后一行
  >
  > 对于 dpLeft 而言：初始化最左一列
  >
  > 对于 dpRight 而言：初始化最右一列

- 遍历方式

  > 对于 dpUp 而言：从上到下
  >
  > 对于 dpBottom 而言：从下到上
  >
  > 其余以此类推

- 答案

  > 只统计 `0` 上的坐标，其上下左右之和，取最大值
  >
  > ```java
  > int res = dpUp[i][j] + dpBottom[i][j] + dpLeft[i][j] + dpRight[i][j];
  > if( res > max ){
  >     max = res;
  > }
  > ```



---

### 统计二进制位中 1 的个数

假设给定一个数 $N$，输出从 0 到 $N$ 的所有数中每一个数的二进制的位数。



#### 思路

如果只输出 N 中二进制 1 的个数，那么循环判断 `n&(n-1)` 即可。但是现在要输出 $[0, N]$ 的每一个数的二进制 1。如果继续使用之前的 `n&(n-1)` ，显然这里有重复计算：

> 比如 `7&(7-1)` 得出 6，然后继续计算 `6&(6-1)` 得出 4。但是此时其实 6 有多少二进制 1 已经确定了。

因此我们可以使用动态规划：
$$
dp[i] = dp[i >> 1] + (i \% 2)
$$


---









## 2. 前缀型

前缀型 DP 一般状态可划分为

> $dp[i]$ 表示前 i 个字符的最优值/方案数/可行性。或者是整个串为 $a$，以 $a_i$ 结尾的某个串的性质
>
> 
>
> $dp[i][j]$ 表示
>
> - 前 i 个字符划分为 j 个部分的最优值/方案数/可行性
> - 第一个字符串的前 i 个部分匹配上第二个字符串的第 j 个部分的最优值/方案数/可行性
>
> 
>
> 有意思的是，类似这种动态规划往往申请的空间都要 +1。



### [房屋染色Ⅱ（困难）](https://www.lintcode.com/problem/516)

这里有`n`个房子在一列直线上，现在我们需要给房屋染色，共有`k`种颜色。每个房屋染不同的颜色费用也不同，我们需要每两个相邻的房屋颜色不同



#### 思路

本题和房屋染色Ⅰ差别在于房屋有 k 种颜色，当 k 过大时采用传统方法时间复杂度可能过高。
$$
dp[i][j] = \min_{k \ne j} (dp[i-1][k]) + costs[i][j]
$$
当我们考察 $dp[i-1][\dots]$ 时，本质上就是找出不在 $j$ 列的最小值，有两种可能：

- 最小值不在 $j$ 列：此时目标最小值就是该最小值
- 最小值在 $j$ 列（即就是当前坐标的正上方）：此时目标最小值就是上一行的第二小值

因此我们相当于需要存储两个 tuple：分别是最小值的 `(值,索引)` 和第二最小值的 `(值,索引)`。当最小值在 $j$ 列时，使用第二小值的索引；当最小值不在 $j$ 列时，就是用最小值的索引。



---

### [打劫房屋](https://www.lintcode.com/problem/392/)

一个窃贼准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。相邻的房屋不能被同时打劫。问最多能打劫多少钱。



#### 思路

假设 $dp[i]$ 表示打劫 $[0,i]$ 房屋所能收获的最多的金额，那么对于第 $i$ 个房屋：

- 如果打劫，那么 $i-1$ 就必然不能被打劫，因此只能跳过 $i-1$ 而去考虑区间 $[0, i-2]$，即 $dp[i] = dp[i-2]$
- 如果不打劫，那么该房屋的金钱就不能加入已打劫金额中，因此区间 $[0, i]$ 的最大金额相当于区间 $[0, i-1]$ 

综上考虑：$dp[i] = \max(dp[i-2]+a[i], dp[i-1])$



#### 优化思路

其实严格来说，某一个坐标只依赖其前一个坐标和前前坐标，因此只需要三个变量，而非一整个 $dp$ 数组即可计算。

再仔细思考可得，每当计算出一个值时，其前前坐标也不必使用，因此只要两个变量，通过何理转换即可解决此题

```c++
// cur 同时扮演前前坐标和当前坐标的角色
long cur = a[0];
long pre = max(a[0], a[1]);
for(int i = 2; i < n; i++) {
    // 通过前前坐标 (cur) 计算当前坐标
    cur = max(cur + a[i], pre);
    // 现在 cur 在 pre 之后，为了维护 pre 和 cur 的相对关系交换它们
    swap(cur, pre);
}
```

计算过程如下：

```java

// 计算过程
--------------------
| cur |	pre	|   	|
--------------------
    |___________|
    
// 交换两数
--------------------
|    |	pre	|  cur |
--------------------
    	 |______|
    
// 交换完成后,继续计算下一个数
-------------------------
|    |	cur	|  pre | 	 |
-------------------------
    	 |____________|
```



----























---

## 3. 背包型

背包型 DP 状态 $dp[i][j]$ 表示取出 $i$ 个物品使得和为 $j$ 的最优值/方案数/可行性

由于背包问题涉及及其广泛，因此单开一个笔记记录。

### [最小划分](https://www.lintcode.com/problem/724)

给出一个正整数数组，把这个整数数组分成S1跟S2两部分，使S1中的和跟S2中的和的差的绝对值最小。

#### 思路

假设整个数组之和为 $SUM$，假设较小那个划分的值为 $X$，则较大的那个为 $SUM - X(\ge 0)$，则两者之差为 $SUM - 2*X$。换句话说，从数组中挑出若干个数使其尽量靠近 $\frac{SUM}{2}$





### 外卖优惠

假设有一张满 $X$ 打折的优惠券以及一组菜品，每个菜都有单价。求最少花多少钱可以用上这张优惠券。

#### 思路

这道题目是求大于等于 $X$ 的最小值。换个思路，将所有菜加总得出总价 $SUM$ ，反过来选择最接近 $SUM - X$ 背包的最大值，最后在逻辑上将这些菜品不选，就得出了大于等于 $X$ 的最小值。

这相当于是背包问题的对偶问题。我们将不打算买的菜作为物品，用它来尽量装满背包





### 石头碰撞

给定一组石头，每个石头有一个正数的重量。每一轮开始的时候，选择两个石头 $x$ 和 $y$ 一起碰撞，碰撞后石头的重量为 $|x-y|$。求最小的剩余石头质量的可能性是多少

#### 思路

认真推敲后可知：将石头分成两堆，这两堆的质量之差，相当于碰撞到最后仅剩的一个石头的重量。又回到了之前的最小划分问题







---

## 4. 区间型

区间型 DP 状态 $dp[i][j]$ 表示区间 i~j 的最优值/方案数/可行性，因为有时候一个大区间往往依赖于小区间的结果，比如回文串判断