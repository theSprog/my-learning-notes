### JNI 方式

#### 第一步

先写一个自定义的（例如叫做 **Test**） class。

```java
public class Test{
  // 下面这句一定要加上，意思是加载一个叫做libtest.so的动态库。这也是我们的要加载的外部实现库
	static {
		System.loadLibrary("test");
	}
    
    // 关键字native表示这是一个本地方法，需要被外部加载的动态库实现，它的实现就放在了staitc块加载的库中。
	native static void sayHello(); 

	public static void main(String[] args) {
		sayHello();
	}
}
```

然后使用 `javac` 编译

```shell
$javac -h . .\Test.java -encoding UTF-8
```

在本目录下就会多出一个 **Test.h**，其中的内容如下（不要手动编辑它，它是机器生成的）：

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class Test */

#ifndef _Included_Test
#define _Included_Test
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     Test
 * Method:    sayHello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_Test_sayHello
  (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif

```

`Java_Test_sayHello`和class里面的`Test.sayHello`是对应的，而其中的两个参数，一个是`JNIEnv`，用于访问虚拟机和使用一些虚拟机提供的调用，而`jclass`则是访问这个类对象在，因为是静态方法所以可以访问到类对象。



#### 第二步

创建一个新的**Test.c**文件，然后实现上面的`Java_Test_sayHello`函数：

```c
#include<stdio.h>
// 实现该头文件
#include "Test.h"

JNIEXPORT void JNICALL Java_Test_sayHello (JNIEnv * env, jclass klazz){
  printf("%s\n", "hello.");
}
```



#### 第三步

直接执行`gcc -shared -fPIC -o libtest.so Test.c`即可，不过如果在include文件的默认目录不包含**jni.h**的话就会报错：

![image-20220817135110767](https://src-1259777572.cos.ap-chengdu.myqcloud.com/image-20220817135110767.png)

因为自动生成的 **Test.h** 引用了这个头文件，这个文件会放在 jdk 目录下的 `include` 文件夹中，所以将命令改为

```shell
$ gcc -shared -fPIC -o libtest.so -I jdk安装目录/include -I jdk安装目录/include/linux Test.c
```

以上两个 `-I` 缺一不可，完成后就可以看到 `libtest.so` 库



#### 第四步

执行

```shell
$ java -Djava.library.path=. Test
```

就行了，`java.library.path`用于指定链接库**libtest.so**的位置，这里假设是在当前目录下。





---

### 用FFI说hello

FFI 是 java 19 的新特性。用 FFI 以上过程只需要两步就够了：

1. 在c中实现并编译为动态库。
2. 在java程序中调用。

#### 第一步

```c
#include<stdio.h>

void sayHello(){
  printf("%s\n", "hello.");
}
```

只需要这样就行了，一个标准的hello程序，其他什么都不需要了。

在执行一个`gcc -shared -fPIC -o libtest.so Test.c`就行了。通常这一步所生成的 `.so` 文件第三方都已经提供了，不必自己手写



#### 第二步

```java
import java.lang.foreign.*; // 需要加载foreign包。
import java.lang.invoke.MethodHandle;

public class Test{
    static {
        System.loadLibrary("test");
    }

    static Linker LINKER = Linker.nativeLinker();
    static SymbolLookup LOADER_LOOKUP = SymbolLookup.loaderLookup();

    public static void main(String[] args) throws Throwable {
        // 在libtest.so 中搜索 sayHello 然后将其绑定到一个 MethodHandle 对象上，然后对其进行调用。
        MemorySegment target = LOADER_LOOKUP.lookup("sayHello").get();
        MethodHandle mh = LINKER.downcallHandle(target, FunctionDescriptor.ofVoid());
        mh.invoke();
    }
}
```

对c代码的改动小了，但是对java代码的改动看起来多了很多，不过在未来的 jdk 中会提供一个叫做 `jexact` 的工具，可以工具c代码自动生成这些java代码，工作量总体会少很多。

需要注意由于此特性还是预览状态，所以需要使用下列命令进行编译

```shell
$ javac --enable-preview --source 19 Test.java
```

同时在进行执行时也需要使用

```shell
$ java --eanble-preview --enable-native-access=ALL-UNNAMED -Djava.library.path=. Test
```



### 总结

JNI和FFI的目标其实并不一样：

- JNI可以访问传递过来的 java 对象也可以访问虚拟机内部的数据结构，JNI的出现更多地是为了让java能够像python那种语言一样，能够轻松访问C/C++编写的库，从而支持深度学习、游戏引擎之类的任务

- 而FFI的目的则更单纯地是为了调用C/C++写的函数（其实不止是C/C++，只要是能够编译为链接库而且对外接口遵守abi的语言就行），在FFI中，无法直接访问到java对象。作为应用程序的开发者使用FFI就能够满足大部分的需求了。









---

### 其他用法

#### 查找外部函数

外部函数的查找通过`SymbolLookup`类（也许可以叫做符号查找器）来进行，有3种方式能够获取到这个类的对象：

- 第一个是获取默认查找器：

> 通过`Linker.nativeLinker().defaultLookup()`，jvm会默认加载一些链接库，在linux下是`libc.so`、`libm.so`、`libpthread.so`等，在windows下也差不多。如果想要调用这些库内的函数，使用默认符号查找器即可。
>

- 第二个是获取加载器查找器：


> 加载器查找器的查找范围是加载器所加载的链接库，因为有些库并不在默认查找器中。
>
> 在上面的例子中`static {System.loadLibrary("test");}`就是让类加载器加载了链接库`libtest.so`。获取加载器的方式为：`SymbolLookup.loaderLookup()`，这样就可以获取到当前类对应的类加载器的查找器。

- 第三个是获取链接库查找器：


> 链接库查找器的查找范围是某个链接库，创建这种查找器的方式是`SymbolLookup.libraryLookup(Path, MemorySession)`，要求提供被加载的库的路径，和一个`MemorySession`对象。
>
> 用这种方式能够**防止不同库中的符号名冲突**。`MemorySession`类在接下来的部分也会说明，链接库查找到的 MemorySegement 对象与这个 MemorySession 对象相关联。



#### MemorySession 

从名字看出来*Memory*代表内存，*Session*代表一个有状态记录的东西，实际上它是用来做内存管理的，负责分配和释放内存，每个MemorySegment 对象都要关联到一个对应的 MemorySession 对象上。

```java
var session = MemorySession.openConfined()
```

在上面我们就使用过`var session = MemorySession.openConfined()`，创建了一个线程本地的 MemorySession，然后使用它来分配内存，注意 `session` 创建后必须要 `close()`通过这样的方式能够保证在session进行了close之后让关联的segment失效，这种过程类似于C里面的free函数，不过也可以让GC来处理这事。

另外就是可以使用`MemorySession.openImplicit()`，这样创建出来的对象会包含一个Cleaner，在对应的MemorySession对象变为不可达之后会对关联的MemorySegment进行清理。



#### 可变参数

如果需要调用类似于`printf`这样的函数，则需要使用可变参数才行了，方法是差不多的，不过需要调用`FunctionDescriptor.asVariadic()`，说明可变部分参数的类型，然后 `invoke` 的时候将可变参数加上就行了。



#### 更多的数据类型

基本数据类型一共是下面几种：

除了基本数据类型（`ValueLayout`）之外，还能够支持其他的数据布局，分别是`GroupLayout`、`SequenceLayout`、`PaddingLayout`这三种。下面就演示一下如何声明并传递一个结构体（struct）好了，对于联合体（union）也是差不多的，两者都是`GroupLayout`，所以使用方式上也差不多。

这里就以下面的C代码为例好了，它接受一个结构体，并打印其字段：

```c
#include<stdio.h>
struct S_ID{ int i; double d; };

void print_S_ID(struct S_ID s_id) {
    printf("{i:%d, d:%d}\n", s_id.i, s_id.d);
}
```

调用它的java方法为：

```java
public class Main {
  public static void main(String[] args) throws Throwable {
    var linker = Linker.nativeLinker();
    var defaultLookup = linker.defaultLookup();
    var S_ID = MemoryLayout.structLayout(JAVA_INT.withName("i"),
            							 MemoryLayout.paddingLayout(4 * 8), // 注意对齐
            							 JAVA_DOUBLE.withName("d"));
    var target = defaultLookup.lookup("print_S_ID").get();
    var funcDesc = FunctionDescriptor.ofVoid(S_ID);
    var handle = linker.downcallHandle(target, funcDesc);
    // 创建 MemorySession 
    try (var session = MemorySession.openConfined()) {
      var segment = session.allocate(S_ID);
      segment.set(JAVA_INT, S_ID.byteOffset(PathElement.groupElement("i")), 100);
      segment.set(JAVA_DOUBLE, S_ID.byteOffset(PathElement.groupElement("d")), 25.4);
      handle.invoke(segment);
    }
  }
}
```

中间有一个`MemoryLayout.paddingLayout(4 * 8)`是因为C结构体的字节对齐要求,而`JAVA_INT.withName("i")`则是给了字段一个名字，便于后续的访问操作。

`segment.set`是进行赋值，`PathElement.groupElement("i")`是构建了一个到名为*i*的字段的查询路径，然后通过`byteOffset`获取了这个路径的offset，查询路径还有多种，可以自己试试看。除了这种方式进行赋值和访问之外，还可以使用VarHandle的方式进行`S_ID.varHandle(PathElement.groupElement("i"))`。

`SequenceLayout`还没有出现过，它能够对应C中的数组，但是因为C函数并不会直接传递一个数组，而是传递数组第一个元素的指针，所以`SequenceLayout`只会作为`GroupLayout`的字段。

比如模拟如下C结构体：

```c
struct i6array{ int arr[6]; };
```

java：

```java
MemoryLayout.structLayout(MemoryLayout.sequenceLayout(6, JAVA_INT).withName("arr"));
```



---

### C 调用 Java

不但可以在 java 程序中调用外部函数（称作 `Downcall`），也可以在外部函数中调用 java 方法（称作 `Upcall`），而除了进行调用之外，也**必须注意关于内存的访问**，因为外部函数使用的内存并不被虚拟机管理。

#### Upcall

upcall和downcall并没有太多差别，下面是个例子：

C：

```c
struct S_ID {
    int i;
    double d;
};

void print_S_ID_proxy(void(*func)(struct S_ID)){
    struct S_ID s = {1, 25.2};
    func(s);
}
```

Java：

```java
public class Main {
    static final GroupLayout S_ID = MemoryLayout.structLayout(
        JAVA_INT.withName("i"), 
        MemoryLayout.paddingLayout(4 * 8),
        JAVA_DOUBLE.withName("d"));
    
    static final VarHandle S_ID_i = S_ID.varHandle(PathElement.groupElement("i"));
    static final VarHandle S_ID_d = S_ID.varHandle(PathElement.groupElement("d"));

    static void print_S_ID(MemorySegment segment) {
        System.out.printf("{i:%d, d:%f}\n", (int) S_ID_i.get(segment), (double) S_ID_d.get(segment));
    }

    public static void main(String[] args) throws Throwable {
        var session = MemorySession.openImplicit();
        var linker = Linker.nativeLinker();
        var libLookup = SymbolLookup.libraryLookup(Path.of("/your/path/to","libtest.so"), session);
        var target =libLookup.lookup("print_S_ID_proxy").get();
        var upcallFuncDesc = FunctionDescriptor.ofVoid(S_ID);
        var upcallHandle = MethodHandles.lookup().findStatic(Main.class,"print_S_ID",
                                                             Linker.upcallType(upcallFuncDesc));
        var upcallStub = linker.upcallStub(upcallHandle,upcallFuncDesc,session);
        var handle = linker.downcallHandle(target,FunctionDescriptor.ofVoid(ADDRESS));
        handle.invoke(upcallStub);
    }
}
```

`static final VarHandle S_ID_i = S_ID.varHandle(PathElement.groupElement("i"));`使用了之前提到过的`VarHandle`来进行访问。

首先需要获取到被C调用的方法的`MethodHandle`，然后利用这个`MethodHandle`创建一个`upcallStub`，实际上在C中会调用到这个`upcallStub`，所以将其作为参数传递给C函数，可以看到C函数接收一个函数指针作为参数，所以upcallStub的作用相当于这个函数指针。

`upcallStub`其实就是对`upcallHandle`的一个包裹，毕竟C中传递过去的是一个C结构体，不可能到了`print_S_ID`就自动变成一个`MemorySegment`，所以是做了这种处理的就是`upcallStub`更多的信息可以查看另外一篇文章。