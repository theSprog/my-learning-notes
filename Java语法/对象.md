### 计算对象大小

maven 引入依赖 `lucene-core`

```xml
<dependency>
    <groupId>org.apache.lucene</groupId>
    <artifactId>lucene-core</artifactId>
    <!-- 4.0.0 有 humanSizeOf, 他返回与其引用树上所有对象的总大小 -->
    <version>4.0.0</version>
</dependency>
```

测试 `lucene` 中的 `RamUsageEstimator.shallowSizeOf()`，返回值是占用多少个字节

```java
public class Test {
    public static void main(String[] args) {
        Integer integer = new Integer(10);
        long c = RamUsageEstimator.shallowSizeOf(integer);  // 16
        String s = RamUsageEstimator.humanSizeOf(integer);  // 16
    }
}
```



### 对象内存布局

当我们在 `new` 一个对象后，该对象的内存区域分为 4 个部分：

- markword

  > 32位虚拟机和64位虚拟机（未开启压缩指针）分别为 4 字节和 8 字节。
  >
  > 假设在 64 位虚拟机下共占 8 个字节，这 8 个字节一共就是：
  >
  > - 锁信息：如果该对象作为一把锁，则锁是否被持有
  > - hashcode：该对象的哈希值，避免重复计算。刚初始化时是没有计算 hashcode 的，等到第一次计算 hashcode 后才会将其缓存起来
  > - age：对象每熬过一次GC，年龄就要+1，待对象到达设置的阈值（默认为15岁）就会被移移动到老年代

- class pointer

  > 共 4 个字节。假如说该类来自 class A，那么这个地方的指针就指向 A.class。
  >
  > 一般 64 位虚拟机的指针本应该占 8 字节的，但是由于 JVM 默认使用压缩类指针，因此一个指针只占 4 字节。对于大多数程序它已经足够了。
  >
  > 在 JVM 中参数添加：`-XX:-UseCompressedClassPointer` 可以关闭压缩类指针，关闭之后一个指针占用 8 字节
  >
  > 
  >
  > 注意：并不是所有的虚拟机实现中对象都要在自身保存类型指针，换句话说访问对象类信息并不一定要经过类本身。（见本章的**对象访问**）

  对象头包括两部分：`markword` 和 `classpointer`。

  如果是数组对象，这里有额外的4个字节用于记录长度（也就是形成了三部分：`markword` 、 `classpointer` 和 `length`）。这也是为什么数组最大的长度是一个 int 的最大值。如果不是数组则没有这部分空间

- instance data

  > 其中：
  >
  > - 原始类型长度不变
  >
  > - 引用类型只是记录一个地址，占 4 字节。（因为压缩普通对象指针）
  >
  >   > 在 JVM 中使用 `-XX:-UseCompressedOops` 关闭压缩普通对象指针
  >
  > - 数组也是一个地址，因此也是 4 字节

- padding

  > 一般按照 8 字节（64 bit）对齐，如果前三项内存大小加起来不是 8 的倍数，那么延长至 8 的倍数。例如 12 填充至 16



### 对象创建

当发生一条 `new` 指令后，JVM 首先先去判断该类是否已经被类加载过，如果没有则先进行类加载。如果已经类加载了，那么会进行如下步骤：

- 为对象在堆中划分内存大小，对象的大小一旦在类加载完毕后通过 `class` 类信息可知

- 分配内存方式也是根据具体的 GC 实现有所不同

  - 见下文详细的 new 过程。接下来的过程是假设对象要在年轻代分配内存

  - 如果内存是完全规整的（即使用过的内存放在一边，未使用的内存放在另一边，中间使用一个指针作为分界点），那么在内存分配时直接将内存指针向空闲区域拨动一个对象大小即可。这种分配叫做指针碰撞

    > 如果垃圾收集器自带有 Compact 能力时，那么每一次 GC 后的内存都是规整的。此时使用指针碰撞即可进行分配。例如 Serial，ParNew 等垃圾收集器就是采用这种方式

  - 如果内存是已用和未用交错在一起，那么必须维护一个已用和未用的链表，分配时在空闲链表上划出一部分空间并更新空闲链表。这种方式称为空闲链表。

    > 像 CMS 这种垃圾收集器，本质上就是已用和未用内存交织在一起。因此内存分配方式也是使用的更为复杂的空闲链表

- 分配时还必须考虑多线程内存竞争的问题

  > 有可能出现正在给 A 分配内存，指针还未来得及修改，线程切换使得本来打算分配给 A 的内存先分配给 B 了，那么线程切换回来之后如果继续给 A 分配原定的内存就会出错
  >
  >  
  >
  > JVM 采用的方式是每个线程先在自己的 TLAB 上分配内存，如果该区域已经占满那么才在公用的区域进行同步内存分配。

- 分配完成后 JVM 还会将 `instance data` 内容初始化为零值。这也就是为什么当对象创建后直接访问总是访问到零值的原因（例如 `int` 总是为 0）

  > 如果使用了 TLAB，那么赋零值也会在 TLAB 分配时就进行

- 之后对对象做必要的信息补充

  > 例如对象的 `class pointer`，如果是数组对象还有数组长度，年龄信息和锁信息等。hashcode 会延迟到第一次计算 hash 值时才保存。

- 调用对象的构造函数

  > 一般而言，JVM 在遇到 `new` 关键字时会在字节码中同时生成 `new` 和 `invokespecial` 两条指令。但是通过其他方式（如反射）时则不一定。





#### new 对象详细过程

不同的垃圾回收器对象具有不同的转移过程。以最流行的 Java8 版本为例：

- 年轻代默认是Parallel Scavenge
- 老年代是Parallel Old



new 过程：

- 当某个对象刚刚 `new` 出来的时候，会先尝试在栈上分配空间。这样做的好处是垃圾清理特别方便，只要弹栈就可以清除对象。

  > 能够在栈上分配对象的前提有两个：
  >
  > - 逃逸分析：确保弹栈之后其他地方不会出现悬垂引用
  > - 标量替换：当发现一个对象不存在逃逸时，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换

- 如果无法在栈上分配：

  - 如果对象过大，直接进入老年代。（JVM 中可以设置临界大小参数）

  - 如果对象不大，通过 TLAB (thread local allocation buffer) 进入年轻代。

    > TLAB 使得每个线程在年轻代内存区中都分有一个自己私有的年轻代。每当一个线程 `new` 对象时，就会先往自己私有内存区存放对象，而不用由于同时放入年轻代同一块内存而出现资源竞争问题

  - 当进行 GC 时，年轻代区域没有被清理的对象进入 `S1` 区域。再次 GC 时进入 `S2`。再次 GC 时回到 `S1`。如此循环往复，直到年龄到达一定程度后进入老年代



### 对象访问

《规范》并没有给定对象的访问方式，只是说引用可以定位到对象而已。主流的访问方式分两种：

- 以句柄（handle）形式访问

  > 有些虚拟机将引用指向一个结构体（句柄），结构体里面存在两个字段，一个字段引用实例（instance data），一个字段引用类（class）。这样做的好处是引用存放的是**不变的**句柄地址，GC 时对象被移动，只需要修改句柄中的指针，而不需要修改引用本身（修改引用本身是更麻烦的）

- 以直接指针访问

  > 大部分虚拟机采取这样一种形式，在每个对象中增设一个字段（class pointer）。因为这样做可以直接访问到对象，而不必像句柄方式那样通过句柄再间接访问到对象，速度更快。
