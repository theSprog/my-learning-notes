## 自适应自旋

JDK6 后默认开启自旋锁，当线程拿不到锁的时候会先去尝试自旋，如果在自旋过程中拿到锁就不必再执行等待（wait）与唤醒（notify）操作。

如果自旋超过一定次数还没有拿到锁，就仍然要进入等待。这个次数默认是 10。用户可以通过 `-XX:PreBlockSpin` 来设定自旋次数。

在 JDK6 之后加入了对自旋锁的优化（这也是为什么 JDK6 后自旋锁才默认开启），引入自适应自旋。自适应是指根据**上一次同一个锁的自旋时间**以及**锁的拥有者的状态**来决定

> 如果同一个锁上一次自旋等待成功获得过锁，那么 JVM 就会认为锁容易获得，允许本次自旋时间更长一些。
>
> 另一方面，如果某个锁很少通过自旋等待获得，那么就会缩小自旋时间，甚至有可能直接省略掉自旋过程。



## 锁消除

锁消除是指对某些加了锁但是却并不存在竞争条件的资源将锁消除掉。

锁消除的主要判断依据是逃逸分析，当某段代码在堆上的所有对象都不会被其他线程所引用到，那么就可以认为它是线程私有的，就可以将它的锁消除

> 比如说字符串相加操作：`s1 + s2` 在 JDK5 之后底层会使用 StringBuffer 类进行拼接，而 StringBuffer 其实是线程安全的，也就是说它内部加入了线程同步操作。然而如果某个字符串只是在线程内部使用，那么这种同步根本没有效果，那么对应的锁也就可以优化



## 锁粗化

大部分时候我们推荐将同步范围缩小。但有时如果强行缩小同步块，从而出现太多零碎的同步块，反复加锁解锁很可能出现性能损耗。

如果 JVM 检测到有这种反复加锁解锁的情况，它会把同步范围扩大到整个操作序列，这样只需要一次加锁解锁就可以了。



## 轻量级锁

### 对象头

在每一个对象的对象头都保存有一个称之为 MarkWord 的字段，它内部包含锁信息，hashcode 和 GC年龄 等信息。

> 32 位虚拟机 MarkWord 长度是 32，64 位虚拟机 MarkWord 长度是 64



### 锁的状态

锁信息包含锁的状态，而一个对象可能有的锁状态有 4 种：

- 无锁

  > 无锁状态下对象 MarkWord 主要记录如下：
  >
  > | hashcode（25） | 分代年龄（4） | 是否偏向（1） | 标志位（2） |
  > | -------------- | ------------- | ------------- | ----------- |
  > |                |               | false         | 01          |
  >
  > 当某个线程访问该锁时，这个锁会升级为偏向锁，意味着这个锁偏向正在访问的线程。
  >
  > 

- 偏向锁

  > 偏向锁状态下对象 MarkWord 主要记录如下：
  >
  > | 线程ID（23）   | Epoch（2）     | 分代年龄（4） | 是否偏向（1） | 标志位（2） |
  > | -------------- | -------------- | ------------- | ------------- | ----------- |
  > | 偏向于哪个线程 | 偏向锁的时间戳 |               | true          | 01          |
  >
  > 所谓偏向锁就是偏向于第一个获取到它的锁，对那个线程进行特殊待遇。
  >
  > 

- 轻量级锁

  > 轻量锁状态下对象 MarkWord 主要记录如下：
  >
  > | 指向栈中锁记录的指针（30） | 标志位（2） |
  > | -------------------------- | ----------- |
  > |                            | 00          |
  >
  > 

- 重量级锁

  > 重量锁状态下对象 MarkWord 主要记录如下：
  >
  > | 指向重量级锁的指针（30） | 标志位（2） |
  > | ------------------------ | ----------- |
  > |                          | 10          |
  >
  > 



### 轻量级锁

synchronized 锁本质上是使用操作系统提供的互斥量来实现的，相对而言更加**重**一些。轻量级锁的目的是在没有多线程竞争锁的基础上，减少传统重量级锁的性能开销。

如果一个对象没有被锁定（标志位为 01，即代表无锁，也代表偏向锁），那么它会在访问线程的栈桢中新增一个 `Lock Record` 记录，它的内容是该锁的 MarkWord 部分。之后虚拟机尝试将该所变成轻量级锁：通过 CAS 操作将对象的 MarkWord 转变为指向 `Lock Record` 的指针。

- 如果成功那么说明已经获取到锁，进入同步块

- 如果失败说明至少有一个线程正在和自己竞争该锁。JVM 会先去查看锁对象的 MarkWord 是否指向当前线程的栈桢：

  - 如果是说明当前线程已经拥有该对象锁，进入同步块。

  - 否则就说明这个锁对象已经被其他线程占有。

    > 一旦出现多个线程竞争同一把锁，那么轻量级锁就不再有效，必须升级成为重量级锁。后面等待锁的线程也必须进入阻塞态。



以上是 CAS 的加锁过程，它的解锁过程也是通过 CAS 进行的，用 CAS 将本线程栈桢中的 MarkWord 替换回锁对象中：

- 如果替换成功，那么整个同步过程就完成

- 否则就说明期间有其他对象获取过该锁，此时应该唤醒等待锁对象的线程

  > 否则说明这把锁已经锁膨胀为重量级锁了，自然存在等待线程需要唤醒。



轻量级锁之所以能够有效的关键是：经验表明，对于大部分锁，即使存在多线程，整个同步过程是也不存在锁竞争的。这表明轻量级锁是一种乐观锁



### 偏向锁

经验表明：很多时候某个锁总是被同一个线程获取并释放。这是人们就提取出偏向锁的概念：锁偏向某一个线程。

如果在执行过程中，某一个锁一直没有被其他线程获取，那么本线程在进入该锁保护的同步代码块时就不用再加锁解锁而进行同步，**偏向锁中的线程 ID 就是指这把锁偏向于哪个线程的**。

当被线程访问该偏向锁时：

- 如果线程 ID 等于该偏向锁的线程ID，那么不用再加锁解锁
- 如果线程 ID 不等于记录的线程 ID，那么该锁会升级为轻量级锁

只有偏向锁被竞争时才会释放锁，持有该锁的线程不会主动的释放锁。



如果说轻量级锁是在无竞争条件下使用 CAS 代替互斥量进行同步操作，那么偏向锁甚至连同步过程都排除了。所以说无竞争时偏向锁相对性能会略优于轻量级锁。

偏向锁在存在竞争时会撤销偏向，撤销后标志位可以恢复到**未锁定**或者**轻量级锁定**，即可以升级为轻量级锁。