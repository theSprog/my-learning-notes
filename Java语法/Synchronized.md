### 作用

使得某一代码片段同一时间最多只能有一个线程在执行



### 用法

- 对象锁

  - 方法锁

    > 默认以 `this` 对象为锁对象

  - 同步代码块锁

    > 自己指定锁对象

- 类锁

  - 修饰静态（static）方法

    > 默认锁对象为当前 class 对象

  - 修饰静态方法内代码块

    > synchronized (*.class)

相比于对象锁，类锁在同一时刻只能被一个对象获取，哪怕是在执行不同的方法。



### 性质

当被锁的方法抛出异常后，JVM 会释放锁



#### 可重入

指的是**同一线程**的外层函数获得锁之后，内层函数可以**直接**再次获取该锁。

`synchronized` 和 `ReentrantLock` 都是可重入锁

优点

- 避免死锁：假设方法 A、B 都是 `synchronized` 且 A 调用 B，如果不可重入则当前线程在 A 内调用 B 时无法再获取到锁，造成死锁
- 提升封装性：避免没有可重入性质时一次又一次的解锁加锁



#### 不可中断

一旦这个锁已经被别人获得了，如果我还想获得，我只能选择等待或者阻塞，直到别的线程释放这个锁。如果别人永远不释放锁，那么我只能永远地等下去。

而某些锁有这种性质：如果某段时间内无法获取该锁，可以去执行其他逻辑



### 原理

#### 加锁解锁时机

进入或者退出同步代码块，退出包括正常退出和异常退出。

> 另一种锁：ReentrantLock 如果异常退出是无法释放锁的

在进入同步代码块时字节码 `monitorenter`，在退出时 `monitorexit` 指令



#### 可重入原理

- JVM 会记录被加锁的次数
- 进入同步代码块加一，退出时减一，直到为 0 则释放锁



#### 可见性

> 一个线程执行的结果，并不一定被另一个线程看见

`synchronized` 可以保证可见性，一个线程退出 `synchronized` 后，他在该代码块内执行的所有结果都会被其他线程看见





### 缺陷

- 效率低

  > 锁的释放情况少、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程

- 不够灵活：

  > 加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的

- 无法知道一个线程是否成功获取到锁